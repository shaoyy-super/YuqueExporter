基于一个基本的PBR Metallic Roughness光照模型修改

贴图导出通道：

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725003911084-34b31d58-ff62-4e04-812c-73af2b937fcb.png)

代码结构：

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725879028383-2eb116d6-32ec-497e-b144-11177635427c.png)



常规镭射材质实现：

清漆 + 薄膜干涉效果实现

![](https://cdn.nlark.com/yuque/0/2024/jpeg/45145007/1725350795356-3d2ef006-cae9-47cf-adcb-472a881a3dc5.jpeg)

![](https://cdn.nlark.com/yuque/0/2024/webp/45145007/1725350673391-c392a222-e696-43bf-a671-db37f3ed5256.webp)



##### 直接光部分：
修改BRDF函数实现清漆和薄膜干涉效果

原BRDF：

<font style="color:blue;">float3</font><font style="color:darkmagenta;"> BRDF</font><font style="color:black;">( </font><font style="color:blue;">float3</font><font style="color:black;"> DiffuseColor, </font><font style="color:blue;">float3</font><font style="color:black;"> SpecularColor, </font><font style="color:blue;">float</font><font style="color:black;"> Roughness, </font><font style="color:blue;">float3</font><font style="color:black;"> N, </font><font style="color:blue;">float3</font><font style="color:black;"> V, </font><font style="color:blue;">float3</font><font style="color:black;"> L,</font><font style="color:blue;">float3</font><font style="color:black;"> LightColor,</font><font style="color:blue;">float</font><font style="color:black;"> Shadow)</font>

<font style="color:black;">{</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> a2 = </font><font style="color:darkmagenta;">Pow4</font><font style="color:black;">( Roughness );</font>

<font style="color:black;"></font><font style="color:blue;">float3</font><font style="color:black;"> H = </font><font style="color:darkmagenta;">normalize</font><font style="color:black;">(L + V);</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> NoH = </font><font style="color:darkmagenta;">saturate</font><font style="color:black;">(</font><font style="color:darkmagenta;">dot</font><font style="color:black;">(N,H));</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> NoV = </font><font style="color:darkmagenta;">saturate</font><font style="color:black;">(</font><font style="color:darkmagenta;">abs</font><font style="color:black;">(</font><font style="color:darkmagenta;">dot</font><font style="color:black;">(N,V)) + 1e-5);</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> NoL = </font><font style="color:darkmagenta;">saturate</font><font style="color:black;">(</font><font style="color:darkmagenta;">dot</font><font style="color:black;">(N,L));</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> VoH = </font><font style="color:darkmagenta;">saturate</font><font style="color:black;">(</font><font style="color:darkmagenta;">dot</font><font style="color:black;">(V,H));</font>

<font style="color:black;"></font><font style="color:blue;">float3</font><font style="color:black;"> Radiance = NoL * LightColor * Shadow * PI;</font>

<font style="color:black;"></font>

<font style="color:black;"></font><font style="color:blue;">float3</font><font style="color:black;"> DiffuseTerm = </font><font style="color:darkmagenta;">Diffuse_Lambert</font><font style="color:black;">(DiffuseColor) * Radiance;</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> D = </font><font style="color:darkmagenta;">D_GGX_UE4</font><font style="color:black;">( a2, NoH );</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> Vis = </font><font style="color:darkmagenta;">Vis_SmithJointApprox</font><font style="color:black;">( a2, NoV, NoL );</font>

<font style="color:black;"></font><font style="color:blue;">float3</font><font style="color:black;"> F = </font><font style="color:darkmagenta;">F_Schlick_UE4</font><font style="color:black;">( SpecularColor, VoH );</font>

<font style="color:black;"></font><font style="color:blue;">float3</font><font style="color:black;"> DirectLighting = DiffuseTerm + SpecularTerm;</font>

<font style="color:blue;"></font><font style="color:blue;">return</font><font style="color:black;"> DirectLighting;</font>

<font style="color:black;">}</font>

<font style="color:black;"></font>

<font style="color:black;">修改后：</font>

添加变量

ClearCoat 控制清漆强度

ClearCoatRoughness 清漆的粗糙度

ClearCoatNormal 计算清漆的法线

float3 EnergyLoss = float3(0.0,0.0,0.0);

float3 ClearCoatLighting = ClearCoatGGX(ClearCoat, ClearCoatRoughness, ClearCoatNormal, V, L, EnergyLoss);

直接计算清漆ClearCoatLighting

清漆GGX函数：

```plain
float3 ClearCoatGGX( float ClearCoat,float Roughness, float3 N,float3 V, float3 L,out float3 EnergyLoss)
{
	float3 H = normalize(L + V);
	float NoH = saturate(dot(N,H));
	float NoV = saturate(abs(dot(N,V)) + 1e-5);
	float NoL = saturate(dot(N,L));
	float VoH = saturate(dot(V,H));

	float a2 = Pow4( Roughness );
	
	// Generalized microfacet specular
	float D = D_GGX_UE4( a2, NoH );
	float Vis = Vis_SmithJointApprox( a2, NoV, NoL );
	float3 F = F_Schlick_UE4( float3(0.04,0.04,0.04), VoH ) * ClearCoat;
	EnergyLoss = F;

	return (D * Vis) * F;
}
```

得到表面清漆效果

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725352351998-7e4832ab-3946-4ff2-91fd-1c6d5633ba2e.png)

添加变量

Iridescence镭射强度

IridescenceThickness镭射厚度



float topIor = lerp(1.0f, 1.5f, ClearCoat);

用清漆影响薄膜干涉强度

float viewAngle = lerp(NoV,sqrt(1.0 + Sq(1.0 / topIor) * (Sq(dot(N, V)) - 1.0)),ClearCoat);

用清漆影响薄膜干涉角度

float3 F_Iridescence = EvalIridescence(topIor, viewAngle, IridescenceThickness, SpecularColor);

F = lerp(F,F_Iridescence,Iridescence);

得到F项计算镭射



EvalIridescence函数和写法搬运自Unity内置

```plain
// Evaluate the reflectance for a thin-film layer on top of a dielectric medum.
real3 EvalIridescence(real eta_1, real cosTheta1, real iridescenceThickness, real3 baseLayerFresnel0, real iorOverBaseLayer = 0.0)
{
    real3 I;

    // iridescenceThickness unit is micrometer for this equation here. Mean 0.5 is 500nm.
    real Dinc = 3.0 * iridescenceThickness;

    // Note: Unlike the code provide with the paper, here we use schlick approximation
    // Schlick is a very poor approximation when dealing with iridescence to the Fresnel
    // term and there is no "neutral" value in this unlike in the original paper.
    // We use Iridescence mask here to allow to have neutral value

    // Hack: In order to use only one parameter (DInc), we deduced the ior of iridescence from current Dinc iridescenceThickness
    // and we use mask instead to fade out the effect
    real eta_2 = lerp(2.0, 1.0, iridescenceThickness);
    // Following line from original code is not needed for us, it create a discontinuity
    // Force eta_2 -> eta_1 when Dinc -> 0.0
    // real eta_2 = lerp(eta_1, eta_2, smoothstep(0.0, 0.03, Dinc));
    // Evaluate the cosTheta on the base layer (Snell law)
    real sinTheta2Sq = Sq(eta_1 / eta_2) * (1.0 - Sq(cosTheta1));

    // Handle TIR:
    // (Also note that with just testing sinTheta2Sq > 1.0, (1.0 - sinTheta2Sq) can be negative, as emitted instructions
    // can eg be a mad giving a small negative for (1.0 - sinTheta2Sq), while sinTheta2Sq still testing equal to 1.0), so we actually
    // test the operand [cosTheta2Sq := (1.0 - sinTheta2Sq)] < 0 directly:)
    real cosTheta2Sq = (1.0 - sinTheta2Sq);
    // Or use this "artistic hack" to get more continuity even though wrong (no TIR, continue the effect by mirroring it):
    //   if( cosTheta2Sq < 0.0 ) => { sinTheta2Sq = 2 - sinTheta2Sq; => so cosTheta2Sq = sinTheta2Sq - 1 }
    // ie don't test and simply do
    //   real cosTheta2Sq = abs(1.0 - sinTheta2Sq);
    if (cosTheta2Sq < 0.0)
        I = real3(1.0, 1.0, 1.0);
    else
    {

        real cosTheta2 = sqrt(cosTheta2Sq);

        // First interface
        real R0 = IorToFresnel0(eta_2, eta_1);
        real R12 = F_Schlick(R0, cosTheta1);
        real R21 = R12;
        real T121 = 1.0 - R12;
        real phi12 = 0.0;
        real phi21 = PI - phi12;

        // Second interface
        // The f0 or the base should account for the new computed eta_2 on top.
        // This is optionally done if we are given the needed current ior over the base layer that is accounted for
        // in the baseLayerFresnel0 parameter:
        if (iorOverBaseLayer > 0.0)
        {
            // Fresnel0ToIor will give us a ratio of baseIor/topIor, hence we * iorOverBaseLayer to get the baseIor
            real3 baseIor = iorOverBaseLayer * Fresnel0ToIor(baseLayerFresnel0 + 0.0001); // guard against 1.0
            baseLayerFresnel0 = IorToFresnel0(baseIor, eta_2);
        }

        real3 R23 = F_Schlick(baseLayerFresnel0, cosTheta2);
        real  phi23 = 0.0;

        // Phase shift
        real OPD = Dinc * cosTheta2;
        real phi = phi21 + phi23;

        // Compound terms
        real3 R123 = clamp(R12 * R23, 1e-5, 0.9999);
        real3 r123 = sqrt(R123);
        real3 Rs = Sq(T121) * R23 / (real3(1.0, 1.0, 1.0) - R123);

        // Reflectance term for m = 0 (DC term amplitude)
        real3 C0 = R12 + Rs;
        I = C0;

        // Reflectance term for m > 0 (pairs of diracs)
        real3 Cm = Rs - T121;
        for (int m = 1; m <= 2; ++m)
        {
            Cm *= r123;
            real3 Sm = 2.0 * EvalSensitivity(m * OPD, m * phi);
            //vec3 SmP = 2.0 * evalSensitivity(m*OPD, m*phi2.y);
            I += Cm * Sm;
        }

        // Since out of gamut colors might be produced, negative color values are clamped to 0.
        I = max(I, float3(0.0, 0.0, 0.0));
    }

    return I;
}

```

得到镭射效果

挂上贴图并调参

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725352529611-b0d5047b-b877-4981-95b5-a002aa7e121e.png)

（贴图换成黑色比较明显）

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725352545501-6b29f1b5-b28a-49ed-b5c1-459e2ca6c4d1.png)



##### 间接光部分：
添加参数IridescenceIBL控制间接光部分镭射

与直接光同理

float topIor = lerp(1.0f, 1.5f, ClearCoat);

float viewAngle = lerp(NoV,sqrt(1.0 + Sq(1.0 / topIor) * (Sq(dot(N, V)) - 1.0)),ClearCoat);

float3 F_Iridescence = EvalIridescence(topIor, viewAngle, IridescenceThickness, SpecularColor);

<font style="color:#DF2A3F;">SpecularColor</font> = lerp(SpecularColor,F_Iridescence,IridescenceIBL);

使用新的<font style="color:#DF2A3F;">SpecularColor</font>参与计算





##### 根据需求继续修改：
原需求：彩色镭射材质，支持透明或者不透明，彩色可以根据灯光角度变化。

采用较低消耗Dither实现透明

连连看中实现：

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725428383365-732a1a11-c714-481f-ae3a-c1ace0d4256a.png)



搬运dither函数

```plain
	inline float Dither4x4Bayer( int x, int y )
	{
		const float dither[ 16 ] = {
	 1,  9,  3, 11,
	13,  5, 15,  7,
	 4, 12,  2, 10,
	16,  8, 14,  6 };
		int r = y * 4 + x;
		return dither[r] / 16; // same # of instructions as pre-dividing due to compiler magic
	}
```

```plain
              half Dither_Arry8x8(uint2 uv)
              {                 
                  uv=uv%8;
                   float Arry8x8[64] = 
                   {0,32,8,40,2,34,10,42,
                   48,16, 56 ,24, 50, 18 ,58, 26,
                   12,44,4,36,14, 46, 6, 38,
                   60,28,52,20,62,30,54,22,
                   3,35,11 ,43,1,33,9,41,
                   51,19,59,27,49,17,57,25,
                   15,47,7,39,13,45,5,37,
                   63,31, 55,23,61,29 ,53 ,21,
                   };
                return Arry8x8[uv.x*8+uv.y]/64;
}
```

     uint uv = (uint2)input.positionCS.xy;

     half dither2x2_M = Dither_Arry8x8(uv);

     clip(dither2x2_M-_Clip*_Clip/3); //_Clip平方除3让过度更线性

最后输出阶段用裁剪空间坐标进行clip裁剪

实现无需切队列和混合模式低消耗半透效果

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725429473086-76401374-ec86-41e8-a969-b553417e7a13.png)



##### 参数列表：
 BaseMap 主贴图

 BaseColor 主颜色

 MetallicMap 金属度贴图

 Metallic 金属度

Specular 高光强度

Roughness Map 粗糙度贴图

Roughness 粗糙度

Normal Map 法线贴图

Normal 法线强度

EnvRotation  环境光角度

ClearCoat清漆强度

ClearCoatRoughness 清漆粗糙度

Iridescence 镭射强度

IridescenceIBL 间接镭射强度

IridescenceThickness 镭射厚度

Clip透明强度

