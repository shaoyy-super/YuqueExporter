# 问题
地形需要多图层混合，现按16层来讨论，unity地形图层采样需要采样4张权重图，16张albedo和16张noraml，采样数过多，性能问题严重，无法直接使用。所以需要一种性能更优，能在移动端应用的地形方案。

# 目的
1. 效果还原，基础效果尽量与terrain全采的混合方案靠齐。
2. 性能优化，优化其性能，使其能在移动端项目实际落地。

# Unity Terrain方案介绍
unity terrain是全图层混合的方式做的，其原理为：4个图层权重生成一张splatmap，每个图层的权重会占splatmap一个通道，4个图层为一个pass，在该pass会采样4个图层的Albedo和Normal以及对应的splatmap获取权重进行混合，然后多个pass进行叠加。

以16层来算，一共需要16Albedo+16Normal+8Splat共40次采样，这性能开销无论如何也是无法接受的。

## 优化
基于原生Terrain的优化，可以识别一个pass内4个连续id图层权重都为0，则跳过pass。

## 缺陷
实际项目中大部分区域很难保证四个连续id图层都不被使用，所以这种优化方案很难生效。

## 分析整理
首先，我们得找出unity Terrain方案中冗余的性能开销，很明显，对于单个纹素来说，16图层其实际混合的可能也就三四个，剩下的权重都为0，不为纹素color做任何贡献；对此，我们需要一种能精准记录单个纹素所需混合图层id的方案。

# Texture2DArray
我们以记录权重最高的四个id为例，既然已经有了图层id，那我们如何通过id来获取其对应的图层贴图呢，这时，我们就需要引入Texture2DArray技术。

先简单介绍下Texture2DArray，其就是一组具有相同2D纹理属性的一个数组，数组内的纹理贴图需要有同样的宽，高，格式，<font style="color:rgb(68, 68, 68);">它的纹理采样坐标是三维的，就是在传统的U，V方向上在加一层W，这个W表示的就是其中的纹理索引。</font>

![](https://cdn.nlark.com/yuque/0/2024/jpeg/46064633/1728459487203-1fddc74e-42ce-4ed9-93cd-54d59ad69277.jpeg)

## 优点
使用Texture2DAarray除了能方便我们通过id获取贴图外，其还能节省纹理binding的消耗；<font style="color:rgb(68, 68, 68);">CPU端纹理Binding是一个非常耗时的操作，比如我们如果要采样16张单独的纹理，那我们需要对这16张纹理分别进行binding，而如果我们使用Texture2DArray的话，把这16张纹理放到Texture2DArray里去，就只用binding一次，这极大减少了CPU的消耗。</font>

## <font style="color:rgb(68, 68, 68);">缺点</font>
1. Texture2DAarray里的纹理属性要保持一致。
2. opengles3.0以上支持。
3. Texture2DArray不能自由切换压缩格式，需要根据不同平台分别打一份其对应压缩格式的Texture2DArray。

# 方案思路
介绍完了Texture2DArray，接下来说一下如何利用Texture2DArray来实现地形多图层混合。

## 方案一
### 思路流程
所有图层贴图打成AlbedoTexture2DArray和NormalTexture2DArray，对图层权重从大到小进行排序，选出权重最大的4个图层，记录其id和weight，生成对应的idmap以及weight map。（项目用的unity Terrain刷的地形，其数据会记录在TerrainData里，会读取TerrainData里的SplatMap，其记录了各图层的权重信息）

在shader中采样获取idmap和weight，用id采样texture2DArray获取对应图层的albedo和normal，最后根据weight将各图层进行混合。

![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1728367368596-16901c9c-59b7-4919-bf6d-781210d564ed.png?x-oss-process=image%2Fformat%2Cwebp)

### 资源准备
1张AlbedoTexture2DArray，1张NormalTexture2DArray，1张idmap，1张weightmap

### 性能开销
采样数：1次idmap，1次weightmap， 4次AlbedoTexture2DArray，4次NormalTexture2DArray

### 效果
![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1729065660925-0349fd71-1380-4590-aacd-7b00e3a28b9a.png)

### 问题
可以看到，地形图层边界区域有明显的突变，是什么导致的呢？

梳理一下，weightmap是根据权重来排的，其相邻像素之间的权重值对应的可能不是同一个id，也就是说其数据是离散的，这时利用硬件的linear插值，会出现显示错误。

## 方案二
### 思路流程
这个方案是基于方案一，主要是为了解决图层边界突变问题。

既然weightmap数据离散，无法利用硬件的linear插值，那可以在shader中手动进行插值，采样相邻四个像素，若相邻像素有相同id，则同id权重做插值。

### 资源准备
1张AlbedoTexture2DArray，1张NormalTexture2DArray，1张idmap，1张weight map

### 性能开销
采样数：4次idmap，4次weightmap，4次AlbedoTexture2DArray，4次NormalTexture2DArray

对比上个方案多了3次idmap，3次weightmap共6次采样。

### 核心代码
```plain
half2 offsetFix = -half2(0.5, 0.5) / _IDSplatTexSize;
half2 uv_00 = uv1 + offsetFix;
int4 id_00 = SAMPLE_TEXTURE2D(_IDSplat, sampler_IDSplat, uv_00) * 16 + 0.5;

//shader内进行线性插值
half2 uv_10 = uv_00 + float2(1.0, 0.0) / _IDSplatTexSize;
half2 uv_01 = uv_00 + float2(0.0, 1.0) / _IDSplatTexSize;
half2 uv_11 = uv_00 + float2(1.0, 1.0) / _IDSplatTexSize;
int4 id_10 = SAMPLE_TEXTURE2D(_IDSplat, sampler_IDSplat, uv_10) * 16 + 0.5;
int4 id_01 = SAMPLE_TEXTURE2D(_IDSplat, sampler_IDSplat, uv_01) * 16 + 0.5;
int4 id_11 = SAMPLE_TEXTURE2D(_IDSplat, sampler_IDSplat, uv_11) * 16 + 0.5;

const float offsetBilinearFix =   1.0f / 512;
half2 uv_frac = frac(uv1 * _IDSplatTexSize - 0.5 + offsetBilinearFix);

half4 weight00 = SAMPLE_TEXTURE2D(_WeightSplat, sampler_WeightSplat, uv_00);
half4 weight10 = SAMPLE_TEXTURE2D(_WeightSplat, sampler_WeightSplat, uv_10);
half4 weight01 = SAMPLE_TEXTURE2D(_WeightSplat, sampler_WeightSplat, uv_01);
half4 weight11 = SAMPLE_TEXTURE2D(_WeightSplat, sampler_WeightSplat, uv_11);

half4 matchWeight10, matchWeight01, matchWeight11;
matchWeight10.x = sum4((id_00.rrrr == id_10.rgba ? 1 : 0) * weight10);
matchWeight01.x = sum4((id_00.rrrr == id_01.rgba ? 1 : 0) * weight01);
matchWeight11.x = sum4((id_00.rrrr == id_11.rgba ? 1 : 0) * weight11);

matchWeight10.y = sum4((id_00.gggg == id_10.rgba ? 1 : 0) * weight10);
matchWeight01.y = sum4((id_00.gggg == id_01.rgba ? 1 : 0) * weight01);
matchWeight11.y = sum4((id_00.gggg == id_11.rgba ? 1 : 0) * weight11);

matchWeight10.z = sum4((id_00.bbbb == id_10.rgba ? 1 : 0) * weight10);
matchWeight01.z = sum4((id_00.bbbb == id_01.rgba ? 1 : 0) * weight01);
matchWeight11.z = sum4((id_00.bbbb == id_11.rgba ? 1 : 0) * weight11);

matchWeight10.w = sum4((id_00.aaaa == id_10.rgba ? 1 : 0) * weight10);
matchWeight01.w = sum4((id_00.aaaa == id_01.rgba ? 1 : 0) * weight01);
matchWeight11.w = sum4((id_00.aaaa == id_11.rgba ? 1 : 0) * weight11);
half4 blendWeight = lerp(lerp(weight00, matchWeight10, uv_frac.x), lerp(matchWeight01, matchWeight11, uv_frac.x), uv_frac.y);
```

### 效果
![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1729065772562-671b2572-8e83-47c1-8f2e-61e0a3c1968f.png)

### 问题
手动插值的方案，因为需要采样4个相邻像素，所有虽然解决了边界突变的问题，但采样数多了6次。

## 方案三
### 思路流程
方案二中手动插值的采样数过高，那自然就想着是否有什么办法能利用起硬件的bilinear，为解决此问题又做了一版方案。

要解决该问题，那必须使得权重数据连续，既然如此，我给每个图层分配一个权重通道，这样使其单一通道内的数据连续，便可以利用硬件linear插值，从而省下部分的采样开销。

### 资源准备
1张AlbedoTexture2DArray，1张NormalTexture2DArray，1张idmap，1张weightTexture2DArray（4个图层一张贴图）

### 性能开销
采样数：1次idmap，4次weightTexture2DArray，4次AlbedoTexture2DArray，4次NormalTexture2DArray

对比上个方案少了3次idmap共3次采样。

### 效果
![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1728540304249-d7a77c4d-80f9-42fd-9484-84b372569a92.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_1125%2Climit_0)

### 问题
这方案其实算是空间换时间，以16层为例，多了3张权重图，换得采样数-3，但该方案会随着图层总数的增多，所需的权重图也更多，这方案也就愈发不划算。

## 方案复杂环境测试
上述方案在双层混合上效果没什么问题，但实际项目中，部分区域单纹素混合图层只会更多，所以我们也需要进行更多图层混合的效果验证。

### 效果
![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1729065904791-0e384709-d967-42f7-804c-54ccb08a7dfb.png)

### 问题
可以看到，在多余4层图层混合的区域，还是会出现突变的瑕疵，这是由于不同像素内收集的id不同产生了权重歧义导致的。

如下图，像素左图层权重排序为ABCD，而其相邻像素右权重排序为BAEC，左缺了E，右缺了D，相邻两个像素在图层混合后就有了较大的差异，从而产生突变。

![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1728549617780-3db0c608-2ed7-4581-8758-233c6157eaf5.png)

## 方案四-块存储
### 思路流程
我们已经知道了上述方案缺陷产生的原因，现在就要着手解决该问题。

既然相邻纹素歧义太大而产生了问题，那我在根据权重排序id时，把相邻纹素的权重也一起纳入进来，就是相邻4个纹素一起存一份4个纹素最大权重的4个id。

原来的方案只考虑了自身1个纹素的权重，现在则是考虑了相邻4个纹素，会使得过渡更加平滑。

![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1728374677319-9a42acf1-c7a4-4943-b0aa-a26323af1a93.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_450%2Climit_0)

### 资源准备
1张AlbedoTexture2DArray，1张NormalTexture2DArray，1张idmap，1张weightTexture2DArray

### 性能开销
采样数：1次idmap，4次weightTexture2DArray，4次AlbedoTexture2DArray，4次NormalTexture2DArray

对比上个方案采样次数持平。

### 效果
![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1729065961886-3aa5591a-2920-4006-b040-d06c4f1b42bf.png)

### 问题
突变的问题总算是解决了，但这采样开销的性能，实在是难以令人满意，所以又开始琢磨是否有更好的处理方案能优化性能。

## 方案五-间隔采样
### 思路流程
优点的还是落在了权重图的采样上，还是想尽量应用硬件的linear插值来节省额外的采样开销。

在说具体做法前，我们先梳理一下手动linear插值的流程：

1. 采样4个相邻纹素id
2. 采样4个相邻纹素weight
3. 筛选出与自身纹素id相同的相邻纹素id其对应权重，若无对应id则用0填充权重
4. 对上述结果进行bilinear

间隔采样就是一种将上述1-3步骤提前在贴图中完成，从而符合硬件插值条件的优化思路。

![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1728376241182-092d8ee7-e3a0-4589-b493-31771141e7c6.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_1125%2Climit_0)

注：左边是扩大后weightmap，右边为初始的weightmap，黑色ABCD为原本的块信息，红色ABCD为拓展的块	信息。

### 实现步骤
1. 将weight map拓展一倍
2. 将黑A的id赋给红BCD。
3. 红BCD的id若与黑BCD的id相同，则取其对应的weight。
4. 若红BCD的id不存在于黑BCD，则赋0。
5. shader采样weight时重构uv，块A：0-1 -> 块ABCD 0-1

```plain
float2 GetHalfPixelUV(float2 uv, float texSize)
{

		uv -= 1.0 / texSize;
		float texHalfSize = texSize * 0.5f;

		float2 halfUV = floor(uv * texHalfSize) / texHalfSize;

		float2 halfUVLerp = frac(uv * texHalfSize) / texHalfSize;

		return halfUV + halfUVLerp * 0.5 + 0.5 / texSize;
}
```

### 性能开销
1次idmap，1次weightmap，4次AlbedoTexture2DArray，4次NormalTexture2DArray

对比上个方案少了3次weightmap共3次采样。

注：weightmap分辨率翻倍，但只要一张贴图，避免了之前方案4个图层一张权重图的尴尬。

### 效果
![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1728562582270-0f293a8a-a328-45c9-b86e-6e67829d3e31.png)

可以看到效果和之前保持了一致。

### 问题
权重图分辨率翻倍。

# 总结
对现有方案进行一个总结

1. 块存储方案+间隔采样
2. 地形最大图层数：12（可拓展，限制是对项目来说暂时够用了，避免美术无限制使用）
3. 单纹素支持4图层混合
4. <font style="color:#333333;">贴图（12层来算）：</font>

<font style="color:#333333;">Albedo Texture2DArray（512）x 12</font>

<font style="color:#333333;">Normal Texture2DArray（512）x 12</font>

<font style="color:#333333;">ID map（512）x 1</font>

<font style="color:#333333;">Weight map（1024）x 1</font>

5. 采样数：

<font style="color:#333333;">1次ID map</font>

<font style="color:#333333;">1次Weight map</font>

<font style="color:#333333;">4次Albedo</font>

<font style="color:#333333;">2次Normal</font>

## 效果对比
<font style="color:#333333;">unity terrain图层全混</font>

![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1728380610606-f0c88c64-c07b-4b78-a024-68d31e298fcd.png)

块存储+间隔采样

![](https://cdn.nlark.com/yuque/0/2024/png/46064633/1728380618952-142e5605-6a03-4fe8-b422-7dc7b54b9ce3.png)

这里两个效果图有所区别是mipmap level不一致导致的。

# 参考资料
[https://zhuanlan.zhihu.com/p/597282014](https://zhuanlan.zhihu.com/p/597282014)

[https://zhuanlan.zhihu.com/p/667325166](https://zhuanlan.zhihu.com/p/667325166)

[https://www.reedbeta.com/blog/texture-gathers-and-coordinate-precision/](https://www.reedbeta.com/blog/texture-gathers-and-coordinate-precision/)

[http://www.gamelook.com.cn/2020/12/405907](http://www.gamelook.com.cn/2020/12/405907)

[https://www.bilibili.com/video/BV1MC4y1Y7ft/?buvid=XU40B454C6777F0140A17FE3674B5BF82CEA1&from_spmid=tm.recommend.0.0&is_story_h5=false&mid=cvonZ3VWspQPrB6dcMlaZQ%3D%3D&p=1&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=e161b25b-de27-47c1-952d-c45ac876be35&share_source=COPY&share_tag=s_i&spmid=main.ugc-video-detail.0.0&timestamp=1705379498&unique_k=lCheOTy&up_id=138827797&vd_source=0d1f4853da275d7164bd993fe41f61f9](https://www.bilibili.com/video/BV1MC4y1Y7ft/?buvid=XU40B454C6777F0140A17FE3674B5BF82CEA1&from_spmid=tm.recommend.0.0&is_story_h5=false&mid=cvonZ3VWspQPrB6dcMlaZQ%3D%3D&p=1&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=e161b25b-de27-47c1-952d-c45ac876be35&share_source=COPY&share_tag=s_i&spmid=main.ugc-video-detail.0.0&timestamp=1705379498&unique_k=lCheOTy&up_id=138827797&vd_source=0d1f4853da275d7164bd993fe41f61f9)

# 
