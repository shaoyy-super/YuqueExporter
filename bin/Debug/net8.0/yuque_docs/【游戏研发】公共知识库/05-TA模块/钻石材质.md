##### 双Pass模拟真实反射和折射做法：
第一个Pass：

     Blend off  混合模式关闭

     Cull  front  剔除前面只渲染背面



    half3 viewDirWS_dir = normalize(i.viewDirWS);

拿世界空间的视线

    half3 reflect_dir = reflect(-viewDirWS_dir,i.normalWS);

反转一下再用法线reflect得到反射线（其实就是一个简单的IBL）

    half4 refra = SAMPLE_TEXTURECUBE_LOD( _RefratTex,sampler_RefratTex,reflect_dir,0)* _RefratIntensity;

    half4 refle = SAMPLE_TEXTURECUBE_LOD( _ReflectTex, sampler_ReflectTex,reflect_dir,0);

用反射线采样cubemap图得到折射和反射，折射加一个_RefratIntensity控制强度

    half4  c =refra*refle* _Color;

折射*反射*颜色

    return c;



第二个Passl:

    Blend One One 混合模式直接叠加前一个Pass的效果

    Cull  back 剔除被立案只渲染前面



 half3 viewDirWS_dir = normalize(i.viewDirWS);

 half3 reflect_dir = reflect(-viewDirWS_dir,i.normalWS);

拿视线和计算反射向量

 half Fre = 1 - saturate( dot(viewDirWS_dir,i.normalWS));

视线dot法线得到菲涅尔因子

 Fre = max(pow(Fre,_F_Power),0.0001)*_F_Intensity+ _F_Bisa;

对菲涅尔因子加强度控制_F_Intensity和偏移值_F_Bisa

 half4 Fre_Color = Fre* _F_Color;



 half4 refra = SAMPLE_TEXTURECUBE_LOD( _RefratTex,sampler_RefratTex,reflect_dir,0);

 half4 refle = SAMPLE_TEXTURECUBE_LOD( _ReflectTex, sampler_ReflectTex,reflect_dir,0)*Fre;

同理计算折射反射，对反射*菲涅尔

 half4 c=refra*refle* _Color2;

折射*反射*颜色

 return c+Fre_Color;

加上菲涅尔颜色影响







![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725362502267-6a814f57-2fd7-4b13-a6dc-322e4476748f.png)

```plain
Shader "Custom/diamond1"
{
    Properties
    {
       [HDR]_Color("Color Back",Color)=(1,1,1,1)
       _RefratTex("RefratTex",Cube) = "white" {}
       _RefratIntensity("RefratIntensity",Range(0,5))=1
       _ReflectTex("ReflectTex",Cube) = "white"{}
       [HDR]_Color2("Color_Front",Color)=(1,1,1,1) 
       _F_Power("_F_Power",Range(0,20))=1
       _F_Intensity("F_Intensity",Range(0,5))=1
       _F_Bias("_F_Bias",float)=0
       [HDR]_F_Color("_F_Color",color)=(1,1,1,1)
    }
    SubShader
    {
       Tags { "Queue"="Transparent" "RenderType"="Transparent"   "RenderPipeline" = "UniversalPipeline" }
        LOD 100

        Pass
        {
        
           Tags{"LightMode" = "UniversalForward"}
           Blend One One 
           Cull  back

           HLSLPROGRAM

           #pragma vertex vertex
           #pragma fragment frag
         
           #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
           #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
           #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
          
           CBUFFER_START(UnityPerMaterial)
           float4 _Color,_Color2,_F_Color;
           float _RefratIntensity;
           float _F_Power,_F_Intensity,_F_Bisa;
           CBUFFER_END

           TEXTURECUBE(_RefratTex);        SAMPLER(sampler_RefratTex);
           TEXTURECUBE(_ReflectTex);    SAMPLER(sampler_ReflectTex);


              struct Attributes
            {
            float4 positionOS   : POSITION;
            float3 normalOS     : NORMAL;
            float2 uv     : TEXCOORD0;

            };

              struct Varyings
            {
            float2 uv : TEXCOORDO;
            float4 positionOS : TEXCOORD3;
            float3 positionWS :TEXCOORD1;
            float3 positionVS :TEXCOORD2;
            float4 positionCS  :SV_POSITION;
            float3 viewDirWS  :TEXCOORD4;
            float3 normalWS  :TEXCOORD5;

            };

            
            Varyings vertex (Attributes v)
            {
              Varyings o = (Varyings)0;
            o.positionOS = v.positionOS;
            o.positionWS = TransformObjectToWorld(v.positionOS.xyz);
            o.positionVS = TransformWorldToView( o.positionWS);
            o.positionCS = TransformWViewToHClip(o.positionVS);
            o.uv = v.uv;
            o.viewDirWS= normalize(_WorldSpaceCameraPos - o.positionWS);
            o.normalWS =normalize(TransformObjectToWorldNormal(v.normalOS));
            return o;
            }
          

            half4 frag (Varyings i) : SV_Target
            {
            half3 viewDirWS_dir = normalize(i.viewDirWS);
            half3 reflect_dir = reflect(-viewDirWS_dir,i.normalWS);
            half Fre = 1 - saturate( dot(viewDirWS_dir,i.normalWS));
            Fre = max(pow(Fre,_F_Power),0.0001)*_F_Intensity+ _F_Bisa;
            half4 Fre_Color = Fre* _F_Color;
            half4 refra = SAMPLE_TEXTURECUBE_LOD( _RefratTex,sampler_RefratTex,reflect_dir,0);
            half4 refle = SAMPLE_TEXTURECUBE_LOD( _ReflectTex, sampler_ReflectTex,reflect_dir,0)*Fre;
            half4 c=refra*refle* _Color2;
            return c+Fre_Color;
            }

         ENDHLSL
               
        }


        Pass
        {
          Tags{"LightMode" = "SPRDefaultUnlit"}
          Blend off
          Cull  front


         HLSLPROGRAM
         #pragma vertex vert
         #pragma fragment frag

        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
       

         CBUFFER_START(UnityPerMaterial)
         float4 _Color,_Color2;
         float _RefratIntensity;
         CBUFFER_END
               
            TEXTURECUBE(_RefratTex);        SAMPLER(sampler_RefratTex);
            TEXTURECUBE(_ReflectTex);    SAMPLER(sampler_ReflectTex);


          struct Attributes
            {
             float4 positionOS   : POSITION;
             float3 normalOS     : NORMAL;
             float2 uv     : TEXCOORD0;

            };

            struct Varyings
            {
            float2 uv : TEXCOORDO;
            float4 positionOS : TEXCOORD3;
            float3 positionWS :TEXCOORD1;
            float3 positionVS :TEXCOORD2;
            float4 positionCS  :SV_POSITION;
            float3 viewDirWS  :TEXCOORD4;
            float3 normalWS  :TEXCOORD5;
            };

            Varyings vert (Attributes v)
            {
               Varyings o = (Varyings)0;
            o.positionOS = v.positionOS;
            o.positionWS = TransformObjectToWorld(v.positionOS.xyz);
            o.positionVS = TransformWorldToView( o.positionWS);
            o.positionCS = TransformWViewToHClip(o.positionVS);
            o.uv = v.uv;
            o.viewDirWS= normalize(_WorldSpaceCameraPos - o.positionWS);
            o.normalWS =normalize(TransformObjectToWorldNormal(v.normalOS));
            return o;
            }
                  
            half4 frag (Varyings i) : SV_Target
            {
            half3 viewDirWS_dir = normalize(i.viewDirWS);
            half3 reflect_dir = reflect(-viewDirWS_dir,i.normalWS);
            half4 refra = SAMPLE_TEXTURECUBE_LOD( _RefratTex,sampler_RefratTex,reflect_dir,0)* _RefratIntensity;
            half4 refle = SAMPLE_TEXTURECUBE_LOD( _ReflectTex, sampler_ReflectTex,reflect_dir,0);
            half4  c =refra*refle* _Color;
            return c;
            }
          
       ENDHLSL
     
        }   
   
   }
     FallBack "Hidden/Universal Render Pipeline/FallbackError"
}

```



##### 




