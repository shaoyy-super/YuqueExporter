# 目的
将渲染模块代码结构成一款可以方便其他组或项目自行接入的插件，同时保持打包体积性能足够好。

需要方便开发、测试。



# 方案
采用类Unversal Render Pipeline源码的组织结构，将渲染模块封装成可被Unity Package Manager进行管理的插件，这样其他项目即可通过Package Manager来从本地注册表、git url、本地带有package.json配置文件的包来高效准确地加载插件。

## URP源码结构
[GitHub - Unity-Technologies/Graphics: Unity Graphics - Including Scriptable Render Pipeline](https://github.com/Unity-Technologies/Graphics/tree/master)

![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721728884932-4d66bfd6-5c5d-4b50-8524-2beb9d26bd85.png)![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721731525828-cb223c36-65d9-4a3b-82c3-996fb809a4f0.png)![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721731537104-474ece48-511e-4a8e-83ac-e85b4a23adb8.png)![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721731554881-ba11b179-01f0-4b7c-99f5-0cab57dd718b.png)![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721731593173-31cd4150-74bd-47d0-be87-5bf3a99c9055.png)

Unity Graphics模块基本采取如下**结构**：

+ Git图形模块仓库
    - Packages							存放基础库
        * urp 	 						 urp库
            + 常见插件目录结构
            + **package.json 			  配置插件信息，外部加载插件时也需要依赖于该配置文件。**
        * ...
    - TestProjects 						存放测试用项目
        * XXX_Tests  	 				 存放测试Unity项目A
            + Assets
            + Packages
                - **manifest.json 		   指定项目依赖，在该文件中添加需要测试用的库**
            + ...
        * ...
    - 一些杂项工具及模版
    - .editorconfig 						规范整体项目的字符集等编码规范
    - .gitattributes 						用于git lfs追踪大文件
    - .gitignore 						用于git提交时忽略特定文件及文件夹
    - 相关说明文档



### 好处
比起直接复制文件夹、导入xxx.unitypackage，采用Package Manager有如下好处：

1. 可以在package.json中指明插件依赖关系，避免单一插件体积过大或安装步骤过于复杂。
2. 可以直观地观察ChangeLog及版本号，Package Manager也提供了依据版本号进行更新的功能，不区分是本地包还是注册表上的包。
3. 开发完可以直接将插件放在服务器的Git上或者私有化部署的Scoped Registries上，不需要放在本地，降低认知负担。

![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721732958561-a6e5f0bf-38db-4848-a0b3-59f6502b750d.png)

![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721732968185-b529c836-13a8-49bb-9081-04816450234f.png)

![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721732974182-231edee5-b99f-458e-90e6-2b3d328e8ccd.png)



## 实践
当前ArtShowCase结构

![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1722247122086-35e34445-fa1a-4554-8c72-63f3a301f8b1.png)



遵循URP的源码结构，将ArtShowCase项目拆解为渲染插件以及测试工程，现改动后的结构目录如下：

+ UTGraphics 						Git图形仓库
    - Packages 					 渲染模块的插件库
        * com.unity.render-pipelines.core	   URP依赖的Core模块（被自定义过，所以需要额外维护）
        * com.unity.render-pipelines.universal URP模块（被自定义过，需要额外维护）
        * com.ut.rendering			  主要的渲染模块（主要就是开发、维护这个模块）
            + Editor				   运行在编辑器环境下的功能及资源，不参与打包
                - UT.Rendering.Editor.asmdef  		程序集定义，后续会说明
            + Runtime				   运行在打包环境下的功能及资源
                - UT.Rendering.Runtime.asmdef
            + ~~ShaderLibrary			   存放常用着色器的公共函数~~
                - ~~UT.Rendering.ShaderLibrary.asmdef~~
            + Shaders				   存放着色器文件(ShaderLibrary也合到这个文件夹下面)
                - UT.Rendering.Shaders.asmdef
            + Textures				   存放贴图
            + ThirdParty			   存放被改动程度过大，同时并不需要后续维护的第三方插件
                - 例 LWGUI  		    LWGUI shader gui 其内部目录结构和常见package结构一致
            + Samples~			   示例资源，加载插件时默认不会加载，仅作可选项
            + Documentation~		   库文档，加载插件时默认不会加载，仅作可选项
            + CHANGELOG.md		   日志文档，尽量记录
            + README.md			   说明文档
            + **package.json			   库的配置信息，后续会详细说明**
    - TestProjects 					 插件的测试工程
        * UTRendering_Test			  渲染模块的开发及测试工程
            + Assets
                - 开发及测试用的示例资源（原ArtShowCase主要资源）
            + Packages
                - **manifest.json		     测试工程的依赖文件，后续会详细说明**
            + ProjectSettings
    - .editorconfig					 项目编码规范
    - .gitattributes					 git lfs大文件追踪列表
    - .gitignore					 git 忽略文件列表
    - README.md					 库说明文档



**package.json:**

[包清单 - Unity 手册](https://docs.unity.cn/cn/2022.3/Manual/upm-manifestPkg.html#changelogUrl)

![com.ut.rendering package.json](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721734018713-23b31044-a968-4842-8961-5ff848c50503.png)![com.unity.render-pipelines.universal package.json](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721734025295-d6777286-cd05-4b18-8bb7-4c25cf61ea92.png)

两者对比再结合unity官方文档可以总结，package.json中需要如下**必要参数**：

+ name 包的正式名称，用于注册包，应以如下格式：<域名扩展>.<公司名称>开头。例如，com.example;
+ description 对包的简要介绍。
+ version 需采取如下格式: MAJOR.MINOR.PATCH，具体可见[Semantic Versioning](https://semver.org/spec/v2.0.0.html)。
+ displayName 显示在Package Manager里的名字，简单易懂为主。
+ unity 指明最低的unity版本，如"2022.3"

可选参数：

+ author 包的作者信息，一般填写公司名。可以带上邮箱及网址
+ dependencies 包对其他插件的依赖信息，这里只能填包名及版本号，因此只能关联注册表上的包
+ samples 包中所包含的示例信息，配置了可方便用户自行选择加载示例，方便测试插件功能



**manifest.json:**

![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721734917990-9a7fc74d-cf81-46fa-8f9e-00daee0b2aba.png)

观察manifest.json可发现目前项目中已经采取了3种Package Manager安装包的方式：

+ 包名 + 版本号：这种方式一般适用于已上传至Unity官方注册表或私有化部署注册表上的包。
+ 包名 + http网络地址：这种方式一般适用于存放在git服务器上的包。
+ 包名 + file本地地址：这种方式也就是俗称的本地安装，选取本地包，直接加载，这也是开发插件的一般方式。

除此之外，还有一种安装方式，就是直接将包拖放至Unity项目的Packages（与Assets同级的Packages）里。这种安装方式和第三种包名 + file本地地址的安装效果比较类似，都能实现在项目中直接对插件内容进行，因此也可以用这种方式来开发插件。



**asmdef程序集：**

[程序集定义和包 - Unity 手册](https://docs.unity.cn/cn/2022.3/Manual/cus-asmdef.html)

Unity中封装成插件的项目一般为了代码的结构性，依赖的清晰，需要采用程序集的概念来封装C#文件。

命名方式：

Editor/[YourCompany].[YourPackageName].Editor.asmdef

Runtime/[YourCompany].[YourPackageName].asmdef

Tests/Editor/[YourCompany].[YourPackageName].Editor.Tests.asmdef

Tests/Runtime/[YourCompany].[YourPackageName].Tests.asmdef



工作方式：

![UT.Rendering.Editor.asmdef](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721735638380-5aa10883-a5a4-4dbf-8d88-557a2b1e360b.png)![UT.Rendering.Runtime.asmdef](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721735649864-1cba024d-41ee-49ee-ba4e-6959396369c6.png)

如上两张图所显示，

+ 程序集可以在其所在的文件夹内定义局部的项目设置，如“allow unsafe code"等。而非整个工程采用一个项目设置。
+ 可以显式指明该程序集对其他程序集的具体依赖，明确依赖关系。
+ 可以明确该程序集在什么环境下执行，如Editor的程序集仅会在编辑器状态下运行，不会参与任何打包。而Runtime的程序集则一般无此限制。但视情况来说，程序集也可以用来为PC、Android、iOS等平台设置单独代码文件夹。
+ 除了指明依赖关系，还可以在Version Defines中具体指明依赖的版本号



问题：

程序集具有传染性，Unity项目中，不包含插件，Assets目录中有一个地方用了程序集，其他地方常常因为依赖的复杂性，也需要因此而额外建立一个程序集。需要耗费一定心智进行管理。



### 安装方式
当前因为没有私有化部署注册表，只能采取将URP和RenderPipelines.Core当做和UT.Rendering同级的插件进行加载，同时UT.Rendering依赖于URP，URP依赖于RenderPipelines.Core。因此，安装方式就是

1. 在项目中打开Package Manager，选择从git进行安装，输入http://192.168.2.240/Programmer/UTRendering.git?path=/Packages/com.unity.render-pipelines.core。第一步是安装URP的依赖Core模块。
2. 从git进行安装，输入http://192.168.2.240/Programmer/UTRendering.git?path=/Packages/com.unity.render-pipelines.universal。第二步是安装UTRendering的依赖URP模型。
3. 从git进行安装，输入http://192.168.2.240/Programmer/UTRendering.git?path=/Packages/com.ut.rendering。最后就是安装核心的渲染模块。

注意，通过git方式安装的模块，项目是无法直接对其进行编辑的。一般来说，这是给其他组使用的方式，也不希望其他人进行改动。



注意：可以选择直接在mainfest.json中，将三个插件依赖一次性全部填写上，这样只用在Unity中刷新一下，就会一次性安装上三个仓库。

```json
{
  "dependencies": {
    "com.unity.render-pipelines.core": "http://192.168.2.240/programmer/ut-graphics.git?path=/Packages/com.unity.render-pipelines.core",
    "com.unity.render-pipelines.universal": "http://192.168.2.240/programmer/ut-graphics.git?path=/Packages/com.unity.render-pipelines.universal",
    "com.ut.rendering": "http://192.168.2.240/programmer/ut-graphics.git?path=/Packages/com.ut.rendering",
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1723525678451-aad189e8-2a2e-4de2-bac7-f36f27138d4e.png)



#### 版本管理
[Git 依赖关系 - Unity 手册](https://docs.unity.cn/cn/2022.3/Manual/upm-git.html)

+ 常见默认最新版本：http://192.168.2.240/Programmer/UTRendering.git?path=/Packages/com.ut.rendering
+ 锁定某个版本：http://192.168.2.240/Programmer/UTRendering.git?path=/Packages/com.ut.rendering#r/rendering-0.1.0
+ **锁定某个分支**：http://192.168.2.240/Programmer/UTRendering.git?path=/Packages/com.ut.rendering#develop



##### 关于URP官方库的版本号，采取在patch version，即第二个小数点后面的版本号后追加三位数001作为自己版本的计数器。
例如：

官方：com.unity.render-pipelines.universal: 14.0.10

修改后：com.unity.render-pipelines.universal: 14.0.10001

当官方库更新后，三位计数器复位从001重新开始计数。



##### 采用分支作为版本号管理，分支文件夹r代表release，例子：
分支：r/rendering-0.1.0 代表rendering库的0.1.0版本



##### 测试了一下package.json里指定高版本依赖，但是项目的manifest.json里指定低版本git
**测试结果显示**：

当用户手动在项目的manifest.json里指定插件A packages.json里的依赖，且使用的是http、git，或者本地链接的形式时，插件A packages.json的dependencies中涉及的相关依赖指定便会失效。因为它会认为项目已经安装了一个相同插件，只是版本无法识别。

**结论**：

当使用http链接做插件管理时，要严格确保项目manifest.json里指定的插件版本互相兼容。因为此时插件packages.json里的dependencies对于采用http安装的依赖是不起效的。



#### Samples维护
只需要维护好Packages/com.ut.rendering/package.json里的samples字段，确保samples中提到的项目确实存在于TestProjects/UTRendering_Test/Assets/Tests/下面即可。

然后运行一下项目根目录下新提供的deploy-samples-win.ps1脚本，它就会自动根据package.json来将开发项目中的Tests Demo按需拷贝到com.ut.rendering的Samples~下面。





### 开发方式
直接通过git拉取UTGraphics库，然后打开其中TestProjects下的项目，测试效果并对插件UTRendering中的代码进行改动。最后注意提交并审核插件UTRendering的改动代码。

