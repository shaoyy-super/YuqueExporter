

# 需求分析：
美术需求：对特定角色设置自定义的Fov，并且该角色移动中不受透视影响



乍看有点矛盾，拆分下需求：

**移动中不受透视影响：**

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1736929498676-d4770f6f-215e-4f33-95fa-e18a87560c7d.png)

正常情况下，由于项目使用的是透视相机，物体从相机的一边运动到另一边时不可避免的会受到透视影响，而美术希望在整个运动过程中都维持中间这个角度

**自定义的Fov:**

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737429613729-0096a04e-d2b2-4260-89c9-1145ffac3b08.png)

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737429868168-4b338a2c-bc8e-40d6-abfa-c936cabd29da.png)

正常情况下，场景内的所有物体的透视效果（近大远小）都是一致的，但对于特定角色，美术希望能够单独调整他们的透视效果以达到美术效果要求



也就是说，美术的需求是，他们既要透视，又不要透视...

（维持一个既定的透视效果）



# 功能实现：
首先考虑如何实现在运动过程中不受透视影响的问题，因为自定义FOV的功能也会受到这个需求的限制

### 移动中不受透视影响：
那么什么情况下物体移动中会不受透视的影响？比较容易想到的是以下两种情况：

1. 正交相机
2. 物体是一个与相机视线方向垂直的平面，且相机到物体所在平面的距离恒定（这点在捕鱼中满足）



1.首先正交相机的方案肯定是不行的，这会破坏游戏的3C导致流程问题，而且完全没有透视也不符合后续需求，但有些思想可以借鉴，下文会提到



2.然后第二个方案的思想就是将模型压成一个片（光照等计算还是按照实际的位置进行，保证效果正确），只要厚度足够小，透视的影响就可以忽略不计，但由于Z-Fighting的原因不可能真正将模型压成片，只能是让它的厚度尽可能减小，经过测试也是能够比较大幅度地减少透视的影响，但透视仍然存在，只能说是起到了缓解作用



**那么是否还存在其他的方法？**

继续分析我们能影响到的流程，说到透视绕不过去的就是MVP矩阵，上面的方案二实际就是在修改M矩阵，包括正交相机下为什么没有透视，理清了它的原理对当前的需求也是有借鉴作用的，那我们拆一下MVP矩阵都干了什么：

简而言之，<font style="color:rgb(17, 17, 17);">M矩阵就是用来将物体顶点 模型空间 的坐标转换为 世界空间 的坐标，V矩阵进一步将物体顶点在 世界空间 的坐标转换为 视图空间 的坐标， 最后P矩阵用来将物体顶点在 视图空间 的坐标转换为 裁剪空间 的坐标。</font>

<font style="color:rgb(17, 17, 17);">正交相机和透视相机的区别就在P矩阵上：</font>

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737453305806-ab2bb6b8-5fbd-4c9f-bd72-ddf612723685.png)

正交相机的视锥是一个长方体，它不像透视相机那样有一个明确的交点，视锥内的物体只要向摄像机朝向的反方向打一道射线就一定能打到近剪裁面上，而透视相机视锥内的物体一定要沿表面到相机位置的的方向打射线才能打到进剪裁平面上，这也是透视相机近大远小的透视效果的由来；那换种思路反过来想，如果让透视相机内的物体沿相机朝向的反方向也能始终打到相机上，是不是就解决了透视的问题？



实际效果类似于: 把相机作为子物体挂在物体身上，这样物体不管怎么移动，物体和相机的相对位置都不会变，还能保有一个不会改变的透视效果，完美符合了第二个需求

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737456964963-9398d440-ef01-482c-8064-4c7cc289c527.png)

当然，不可能真的把相机给挂在物体上，这时候就需要对MVP矩阵中的V矩阵视图矩阵动一动手脚，V矩阵中包含了相机的位置与旋转矩阵，我们只需要将位置与旋转设置为我们期望的值即可



在捕鱼项目中，我们只需要将V矩阵的相机XZ轴坐标设置得与物体枢轴点XZ坐标一致（捕鱼渔场中相机旋转角度与Y轴高度不会变化）



设置V矩阵的方法有两种：

1. 第一种是新建RenderFeature，将需要更改V矩阵的物体单独设置layer，然后在该RenderFeature中设置主相机位置与旋转矩阵，渲染完成后还原
2. 第二种是C#脚本中完成V矩阵的计算，将自定义的V矩阵传入物体shader，shader中使用自定义的MVP矩阵进行计算

两种方法各有优劣，RenderFeature的方法不适用于复数V矩阵的修改，也就是同时出现多个需要修改V矩阵的Boss时需要额外添加layer和RenderPass，不便于管理；传shader的方法可以解决复数修改的情况，但对Scene视图预览不友好，渲染位置会被一起修改；考虑到可能出现复数设置V矩阵的情况，还是选择了外部脚本计算并给shader传递自定义V矩阵的方案





然后，只需要解决最后也是最重要的一个问题，就是虽然移动中透视效果没有变，但是渲染位置同样也没有变...也就是不论角色怎么移动，都只会被绘制在屏幕中心位置，直到移动出视锥体范围被视锥剔除



解决方法是在C#脚本中，根据相机fov，相机坐标与物体坐标计算得出物体在裁剪空间上的偏移量并传递给shader，这样渲染位置就能就能同步世界位置进行移动

eg.

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737511492478-8ba77307-0771-4eb7-8168-a8b172e189a0.png)

假设物体坐标为P，相机与物体高度差为Δh，那么通过 2Δh · tan( fov / 2)就可以得到物体所在高度平面上视锥的长度 2l（x轴），拿 P( x ) - Pcam( x )就能得到物体P在x轴上的偏移量 l', l' / 2l 即为物体在裁剪空间上x轴的偏移量，同理也可以得出裁剪空间上y轴的偏移量，shader中加上这个偏移量即可还原出物体世界空间到裁剪空间的映射关系

以招财猫作为示例： （招财猫只设置了锁定视角的功能，没有Fov）

![](https://cdn.nlark.com/yuque/0/2025/gif/45354151/1737525179986-d350857c-88d6-4a52-be42-1208fdc3b7f1.gif)



然后就是因为渲染位置和实际位置不同步（物体是根据传递的自定义V矩阵进行固定透视效果的渲染，但实际的模型位置其实没有变，虽然有上面做的位置纠正，但渲染位置和实际位置依然是有一定差别的），就会产出一些视锥体剔除和碰撞不一致的问题，需要再针对性做调整



### 自定义的Fov:
其实就是自定义的透视效果，在上述 移动过程中不受透视影响 的实现里已经提供好了一个很好的基础，下面只要专注于实现自定义的透视效果即可

Unity自身提供的RenderFeature里，其实已经有Render Object这么个Feature完成了相关功能的实现，可以在不改变物体世界空间位置的情况下改变物体的渲染位置和fov等设置

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737527586431-c8b6c71b-0e01-4146-8f08-a1c25d34af4f.png)

![](https://cdn.nlark.com/yuque/0/2025/gif/45354151/1737527132637-2592f56d-bbf5-4f8e-8909-3f72be929cfc.gif)



拆一下他的实现逻辑：

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737690052174-6757feb9-f2d1-4b95-9ca0-65699aa96742.png)

可以看到其实就是在渲染这个Pass的时候修改了投影矩阵和视图矩阵，上一步中我们已经处理好了视图矩阵，现在只需要看看怎么修改投影矩阵实现自定义的透视效果即可



![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737690394816-0a4971c0-68f8-4f5f-b58e-6585f15e1d49.png)

参考RenderObjectPass，Matrix4x4.Perspective()是unity提供的构建投影矩阵的函数，需要提供相机的Fov参数，宽高比，近剪裁面距离和远剪裁面距离参数，其中我们实际能够影响的只有相机的Fov

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737690508089-676047d4-229a-4906-9d67-77783e246ca1.png)

ps. 通过Matrix4x4.Perspective()获得的投影矩阵还不是GPU使用的投影矩阵，需要通过GL.GetGPUProjectionMatrix()再做一次转换，自己在外部实现的话还需要考虑到相机的抖动矩阵和API差异



调整下相机Fov看看是什么效果：

![](https://cdn.nlark.com/yuque/0/2025/gif/45354151/1737690060888-4ec6036f-b425-4844-9c48-280114fe7dbb.gif)

发现**在固定视角下**，实际视觉效果其实就是等比缩放的效果，不影响透视强度

所以剩下能影响透视强度的因素就是根据近大远小的原则把物体朝相机拉近，或者直接放大。因为捕鱼项目里面有很多机制是依赖于物体所在高度的，因此选用了直接放大模型的方式来调整透视效果，然后放大后的大小问题通过开放CustomFov参数再等比缩放回去（上面测试过不会影响透视效果），这样就能得到一个可控的透视效果。即，通过脚本给shader传递自定义的VP矩阵，替代Unity提供的TransformObjectToHClip()函数

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737429613729-0096a04e-d2b2-4260-89c9-1145ffac3b08.png)

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737429868168-4b338a2c-bc8e-40d6-abfa-c936cabd29da.png)



但改变完CustomFov后，就会发现移动时的位置又对不上了，现在的移动范围变小了很多。这是因为在扩大Fov的时候，相当于是扩大了整个画布，视野增大了，在世界空间移动相同的距离时，反映到最终画面上移动的比例就减小了

eg.在原始的Fov下，点P可以在屏幕内任意位置移动

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737698864639-9a31ebfa-aea8-42dd-9d81-d4d09b7864b2.png)

但当Fov变大，可视范围扩大时，虽然点P的世界空间坐标没有改变，但它在画面内的活动区域只有虚线内的那一部分了

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737699164175-07c669c6-15a1-40ab-9aa9-f5a6a11aadad.png)

所以，我们还需要找到一个映射关系，不论Fov如何变化，都能让P点出现在画面内的同一个位置，目前使用的方法是找到 P' 点的世界空间位置，在shader计算中将PositionWS加上 P 到 P' 的偏移量![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737699188478-e07ba38a-82d3-4b5f-8ab6-1df2506c09ce.png)



实现思路：

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737700811660-852c5541-e801-4463-adee-ae540bd3aa28.png)

Pcam x,z轴坐标均为0

P点位置已知，P点所在平面的视锥长宽（的一半）L 可以通过 Δh · tan( fov / 2 )得出

同理，可以得出改变fov后的 L' 

联立 P / L = P' / L' 

P' = P / L * L'

ΔP = P' - P



参考代码：

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737701367787-c9204964-c9fb-479b-abd2-442cca08913a.png)

shader:

![](https://cdn.nlark.com/yuque/0/2025/png/45354151/1737701436872-4d201a15-f94f-4b6b-aa2d-aa0abf465fc1.png)

即可将渲染位置映射回实际位置



完成

