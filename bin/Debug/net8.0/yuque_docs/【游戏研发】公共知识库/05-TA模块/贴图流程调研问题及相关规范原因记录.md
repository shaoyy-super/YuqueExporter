## 问题1：SP对于normal通道，在写入内容时会将其转成tangent space再写入，用户自定义的Nrm2通道则是按照原始RGB16F写入。
解决方法：

1. 【可行】有种方法是不用设置nrm2通道，只设置normal通道。然后为了实现同时输出一张合并了所有normal的完备法线图和一张只有mesh normal以及不染色区域法线的图，可以在使用脚本进行导出时，先导出合并了所有normal的图，再将染色区域全部设为不可见，然后导出只带有不染色区域的法线图。
2. 【可行且已验证】通过[SD filter](https://helpx.adobe.com/substance-3d-painter/content/creating-custom-effects/channel-specific-filter.html)中的类似[normal invert](https://helpx.adobe.com/substance-3d-designer/substance-compositing-graphs/nodes-reference-for-substance-compositing-graphs/node-library/filters/normal-map/normal-invert.html)等节点实现转写raw data成法线格式，再写入通道Nrm2。
    1. 验证成功了通过SD制作的filter实现复制normal通道内容到user自定义通道，中间需要在SD中使用normal invert节点来反转Y轴实现DirectX和OpenGL格式之间的转换。该方法需要在所有图层最下面放一张背景图层，用于向Nrm2写入默认法线颜色。
    2. 至于通过SD制作一个filter来转写user通道内容为normal格式，则还有些问题。首先通过normal invert可以将opengl的格式问题解决，此举可以解决填充图层nrm2和normal内容对不上的问题。但是之后依然存在一个paint layer绳子材质的法线内容对不上的问题，怀疑是需要搭配height图来做切线空间的转换。不过考虑到尝试起来比较麻烦，且已经有多个方法能解决这个问题，就不继续了。
3. 【可行且已验证】通过SP的[Anchor Point锚点](https://helpx.adobe.com/substance-3d-painter/features/effects/anchor-point.html)来实现。group里的一个matLayer负责正常内容的写入，同时标记成为锚点，另一个mask layer上建一个fill effect来负责写入nrm2，引用前面锚点里的normal即可实现通道内容复制。假如美术有特殊需求，需要在这里画多层材质用layer，那么调整完多个layer后，把这些layer一起打个组，比如说，形成结构：Group4 -> Group4-mat group -> matLayer1, matLayer2...，然后在Group4-mat group上建一个Anchor Point锚点，由Group4的mask layer建一个fill effect来执行复制normal到nrm2也行。
    1. 不过有个衍生问题：需要把第4-不可染色区域当做（完整贴图 - 第1、2、3区域）。而非存在第1、2、3、4区域，以及（完整贴图 - 第1、2、3、4区域）。即第4区域是指定1、2、3区域后的所有其他部分。

![图1.3a.1：根据ID贴图进行区域划分](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721123989289-ecd23970-0895-4ea2-a7df-31316939bbf9.png) 

![图1.3a.2：贴图区域划分](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721123790726-07d20782-2fae-4e60-b742-455906beba6f.png)

        1. 定义：参考图1.3a.1，对于此贴图，当使用ID贴图对其进行区域划分时，有颜色的只有2、3、4区域，区域1的命名我空着没用上。区域5则是ID贴图中除了有颜色区域外的剩余区域，也是模型没有用上的部分。那么暂且定义 

**第4-不可染色区域 = 4 + 5**；

**2 + 3 + 4 + 5 = 完整贴图；** 

**2 + 3 + 第4-不可染色区域 = 完整贴图**。

> 理论上来说，区域5不管放什么内容进去，都不会影响shader使用，只要shader不采样遮罩外区域，以及对每个采样器设有合理的默认值。不过考虑到输出贴图的规范及易于被不熟悉项目的人理解，还是需要严格考虑这部分区域的内容填充。
>

        2. 问题：假如第4-不可染色区域 = （上图中的4 + 5），那么对于采用fill还是paint的方式绘制内容则需要谨慎考虑，因为fill是采用填充的方式，会填满所有可以绘制的区域，那么第4区域中5的那部分也会被fill给涂上颜色。（这个特性是作为nrm2以及normal填充默认色时所期望的特性，但另一方面，它又是其他通道填充默认色并不期望的。其他通道比如说BaseColor，对于完整贴图中模型外的区域，通常采用的是默认无色透明。）不过采用paint时则不会有此问题，因为用户在使用paint绘制贴图时，一般不会在正方形贴图模型部分外的区域进行绘制。
    2. 就输出贴图规范性来看，即所有贴图其他美术能一眼看明白是什么，还是按老方法采用颜色选择指定第4区域。即

**第4-不可染色区域 = 4 **；

**2 + 3 + 4 + 5 = 完整贴图；** 

**2 + 3 + 第4-不可染色区域 + 5 = 完整贴图**。

的情况，然后在SP所有图层最下面建一个默认色为#8080ff的图层写入Nrm2，作为Nrm2的底色更为合适。



## 问题2：SP无法在项目设置2k分辨率的同时，导出256*256的SD材质四方连续法线贴图，且保持贴图精细度和2k分辨率的精细度一致。
解决办法：

1. 【可以导出贴图，但是精细度问题是另外一个思路】可以通过与复制normal到nrm2通道问题（问题1.1）类似方法来解决。预先准备一个plane或者正方体fbx，由脚本负责在导出所有贴图后，自动加载plane或者正方体，贴上相关材质，然后再导出细节法线贴图。导出完毕后，脚本再将相关plane或者正方体删除即可。
    1. 此方法只能导出与项目分辨率一致的法线贴图。根本问题在于，同一个SD材质，在分辨率设置不同时，生成的细节法线差异较大。同时，也不能从2k分辨率的贴图上扣一块256x256的材质下来，那会导致贴图不能保持四方连续的特征。因此，还是需要去弄清楚SD中四方连续法线贴图的生成原理。
    2. 经测试验证，同一张细节法线图，在SP或者Unity中，只要Tiling的值一致的，那么其纹理结构就是一致的，分辨率会对观感有一些影响，但这也正是为什么要放大精细度，增加固定分辨率区域内信息。
2. 【精细度思路】在SD材质中连接法线导出或者制作TileGenerator时，就需要确保尽量只放个位数个最小可重复单元进去。也就是说实际上Tile Generator只是用来看纹理效果，导出给生产使用时，直接将制作的可四方连续纹理结构重复4个出来，然后连到各个终点上即可。



## 问题3：细节法线Tiling过多后，在Unity中靠近观察时，会呈现出过渡的光斑，有明显的分块现象。
![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1721904566932-d067ec07-a32f-4cbc-8e5e-01c680ead0ed.png)

调查发现，这是因为开启mipmap导致的，不同距离采用不同精度贴图导致的不连续，法线变化太突然。



解决办法：

因为不能关闭mipmap，所以只能考虑tiling过多的细节法线贴图属于什么类型的问题，再寻找其他优化方法。看上去它和斜坡、道路等常见的与精度相关的问题比较相似，那这种问题一般会考虑调节一下三线性过滤或者各向异性设置来看看是否会产生影响。

测试发现三线性过滤Trilinear可以很好解决这个问题，不过三线性过滤对于性能损耗太大，不予考虑，只是验证问题用。

调节各向异性对此问题也有帮助，经测试，各向异性调到2就能实现一个比较好的效果。各向异性的性能影响也不像三线性过滤那么大。



+ 各向异性的原理是：
    - Aniso Level 越高， 纹理采样所需的内存访问次数越多。因为高Aniso Level需要从纹理的不同Mipmap级别和方向上进行采样，这就需要访问到内存中更多不连续的纹理数据。
    - 不连续的内存访问会降低GPU缓存命中率，增加内存带宽压力，从而降低性能。

> <font style="color:rgb(69, 84, 99);">只有Metal, Vulkan and OpenGL 三种APIs，可以分开独立控制mipmap过滤和各向异性过滤等级,。其他图形Api里，一旦打开各向异性，会默认开启三线性过滤。</font>
>

[Unity - Scripting API: Texture.anisoLevel](https://docs.unity3d.com/ScriptReference/Texture-anisoLevel.html)



## 贴图命名规范
贴图命名重新规范了一下，原因如下：

1. 配合FA那套命名 [D], [N], [M];
2. 从一个项目的资源复用角度考虑，一个项目如果使用染色材质，很有可能同时需要使用染色的高配和低配，因此可以将它们放到一个文件夹来节省资源占用。
    1. 一个项目如果使用染色材质，因为染色的功能需求，则该项目不可能再使用烘焙了全部颜色的通用配置；
    2. 一个项目如果使用烘焙了全部颜色的贴图，则也不可能再使用染色材质，没必要了。



配合这两个原因，做出如下**贴图命名规范**及**文件夹结构**调整：

现在SP插件会提供功能输出三种贴图文件夹及json文件：

+ xxx_export
    - UT_Dyeing（需要染色功能的项目自用）
        * $textureSet_H_[D].tga 	高配颜色			(e.g. Tex_CH_103_Body_01_H_[D].tga)
        * $textureSet_H_[N].tga 	高配法线			(e.g. Tex_CH_103_Body_01_H_[N].tga)
        * $textureSet_[A].tga 	遮罩				(e.g. Tex_CH_103_Body_01_[A].tga)
        * $textureSet_[N].tga 	低配法线			(e.g. Tex_CH_103_Body_01_[N].tga)
        * $textureSet_[M].tga 					(e.g. Tex_CH_103_Body_01_[M].tga)
        * T_$unityResolution_$texType_$id_[DN].tga 	(e.g. T_64_Cotton_01_[DN].tga)	    细节法线
    - UT_General（不需要染色功能的项目自用）
        * $textureSet_[D].tga						(e.g. Tex_CH_103_Body_01_[D].tga)
        * $textureSet_[N].tga 					(e.g. Tex_CH_103_Body_01_[N].tga)
        * $textureSet_[M].tga 					(e.g. Tex_CH_103_Body_01_[M].tga)
    - General（外部项目使用）
        * $textureSet_AlbedoTransparency.tga 		(e.g. Tex_CH_103_Body_01_AlbedoTransparency.tga)
        * $textureSet_MetallicSmoothness.tga 		(e.g. Tex_CH_103_Body_01_MetallicSmoothness.tga)
        * $textureSet_Normal.tga 					(e.g. Tex_CH_103_Body_01_Normal.tga)
        * $textureSet_Emission.tga 				(e.g. Tex_CH_103_Body_01_Emission.tga)
        * $textureSet_AO.tga 					(e.g. Tex_CH_103_Body_01_AO.tga)
    - xxx_export_material.json

ps. 

关于细节法线，由于可能多套衣服共用一套细节法线，所以Unity解析脚本会自动将所有的细节法线收纳到一个文件夹内。当有人将新的T_$unityResolution_$texType_$id_[N].tga拖进工程时，会先判断细节法线文件夹内有没有同名的，有就不处理了，没有才会将其拷贝进去。



