

# 问题描述
![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730805838349-dc98dc66-0c75-4c65-9737-09f877a0dc4f.png)

如上图为摄像机视角下URP阴影的投影效果，左右两条鱼位于同一高度，左边的鱼能够显著地看到阴影，但在从左到右移动的过程中阴影逐渐向左偏移，到图中右边鱼的位置时，阴影几乎已经与本体重叠，这在美术角度看，这是一个比较严重的效果问题



# 问题原因
相机为透视相机，平行光投影时是正交投影，即：

![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730799102227-0c63d2a4-5310-4dda-a269-e03decbe8cef.png)

将鱼抽象为图中的蓝色线条



![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730804100713-511ab4b6-313e-493d-86a6-05f7e0c66ac6.png)

鱼在平行光方向的投影位置



![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730804308377-7a1bb659-da3a-444b-bb30-e36273d23817.png)

而在透视相机下，**右边**鱼的投影映射回同一平面后较之本体**向左**有了相当大幅度的偏移；而**左边**鱼的投影映射回以后与本体基本是重叠的，还有一点**向右**的偏移



**这在美术看来是一个效果错误，但从渲染来看是物理正确的**



另：

![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730805298906-25b86ba3-5579-4299-9863-1fec57ef4f0b.png)

在鱼的高度抬升后，投影相对于本体也会偏小，美术同样认为这是一个效果错误



![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730805546475-8e8c8692-9232-477a-a32b-4a0c4be4e596.png)

其实同样还是因为透视相机的原因，**鱼在平行光投影前后的长度 L 是一致的，但经过透视缩放，映射会原来平面上的 L' 是会 < 原本的长度 L 的**，这也是一个物理正确的现象



# 实际需求：
故，美术实际的需求是不论鱼在什么位置、什么高度，鱼的投影相对鱼本身的偏移量都是固定的，且鱼的阴影也始终需要和本体有着相同的大小





# 解决方案：
## 方案A：
**历史设定：**当时的鱼群已经有了压扁功能，普通鱼的高度都在 y=8 平面上下，Boss高度略高一些，但不多



因为鱼之间的高度差异不大，我们先假定它们都在同一平面上，那么我们是否可以通过已知的位置和方向信息推出期望的阴影投影位置在哪里



**已知信息：**地面位置，鱼群高度，相机位置，平行光方向，投影位置（地面shader）

                                                    ![](https://cdn.nlark.com/yuque/0/2024/jpeg/45354151/1730810426729-4f007f93-f102-47a5-88a9-a6c9ff08fac0.jpeg)

![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730809804191-b9f03a02-f7de-4d34-9d43-a61ba4c49592.png)



![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730809915166-d8209b90-7178-43ca-8891-4b442b1a25ca.png)

阴影的偏移量 ΔX 可以由鱼所在平面高度和平行光角度计算得出

![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730810052142-3bec0d0f-7048-4366-9ed5-5c4cb7faced2.png)

以鱼的最左侧端点为例，相机视角出发该点在地面的投影点为 X，X 加上刚刚计算得出的阴影偏移量 ΔX 即是我们期望的阴影投影位置Xt

![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730810813709-b238c1c9-eb18-42f6-9139-58e25c32a474.png)

于是，正推，通过图示箭头流程就可以推出从实际投影点 X' 到 期望投影点 Xt 的计算过程



但我们期望的是让 Xt 点采样 X' 点的Shadowmap，所以将上述流程反推就可以达到在 Xt 点采样 X' 点shadowmap的目的，完成



**shader代码实现（仅地面）：**

```plain
 //Compute ShadowSamplePos
 //临时，替换_ShadowCastHeight
 float tempHeight = 8;
 //计算逻辑：正推：基于实际位置，平行光角度与自定义高度偏移量还原投影物位置，再计算得出相机视角下投影到原平面后的位置，加上阴影偏移量，就是期望的投影位置
 //然后基于上述逻辑反推，可以推出每个点实际需要采样shadowmap的坐标，用这个坐标来采样shadowmap
 Light mainLight = GetMainLight();
 float3 pixelPos = i.worldPos;
 //阴影偏移量
 float3 moveDir = mainLight.direction;
 float fixedY = max(0.00001, moveDir.y);
 float length = tempHeight / fixedY;
 float2 deltaXZ = float2(moveDir.x, moveDir.z) * length;
 //相机视角投影到原平面的位置
 float3 projPos = pixelPos + float3(deltaXZ.x, 0, deltaXZ.y);
 //计算投影物位置
 float disToCamY = abs(i.cameraPos.y - projPos.y);
     //中心点不为（0，0）时
     //float2 centerpos //外部赋值
     //float2 fishPosXZ = (float2(projPos.x, projPos.z) - centerpos) * (disToCamY - _ShadowCastHeight) / disToCamY + centerpos;
 float2 fishPosXZ = float2(projPos.x, projPos.z) * (disToCamY - tempHeight) / disToCamY;
 float3 fishPos = float3(fishPosXZ.x, tempHeight, fishPosXZ.y);
 //计算实际采样位置
 float3 samplePos = fishPos - moveDir * length;

 float4 SHADOW_COORDS = TransformWorldToShadowCoord(i.worldPos);
 //float4 SHADOW_COORDS = TransformWorldToShadowCoord(samplePos);
 mainLight = GetMainLight(SHADOW_COORDS);

	half shadow = MainLightRealtimeShadow(SHADOW_COORDS);
```



因为鱼群高度比较接近，所以计算结果就算有少许偏差也在接受范围之内，只要高度不差太多就行...







然后不出意外的话就要出意外了...

![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730811867927-5097caa6-ddb2-48b3-8213-8a59ec3d946b.png)

兔女郎因为已经K好了动画，简单的大小缩放无法应用到动画轨迹，所以动作那边采取了模型上移的方式，通过近大远小来解决整体放缩问题，而方案A做法的前提是假定鱼群都在一个高度接近的平面，只能在高度相差不大的情况下起效



然后方案A就寄了.....  一半



## 方案B：
方案B实际是方案A的补丁，整体思路还是一致的，只是要解决各物体投影高度不一致的问题

方案A只是更改了地面shader中计算投影的偏移量，而在地面shader中，其他鱼的位置都是未知的，所以无法为每一条鱼计算各自的偏移量；要想解决部分鱼高度差别过大的问题，就只能对ShadowCaster下手

![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730812878325-00478c7c-9e1a-42ad-9dac-bce07414eaa8.png)

大致思路是将较高的鱼B的位置投射到与代表大多数鱼的鱼A一致的高度即可（需要应用透视变换），然后就可以继续执行方案A



投影前需要将模型沿平行光方向拍扁至模型根节点transform.y所在平面，否则投影可能不正确；对于兔女郎这种模型本体相对根节点还有偏移的情况还需要传递一个高度偏移量来修正拍扁的高度；transform.y和高度偏移量由程序赋值





或者...

直接全部投影到地面？

**↓↓↓↓↓↓↓↓↓**

## 方案C：
依照方案B的拓展思路将全部鱼的ShadowCaster全部投射到地面，然后就会发现有一张似曾相识的图和这个做法得到的结果是十分相似的



深度图

![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730813343753-b6adb6fe-9eb3-4d09-803a-9565b1a3b077.png)

已经包含了透视投影关系，只要在地面shader中**拿屏幕坐标对深度图采样**，再**加上一点自定义的偏移**就可以模拟出符合美术需求的阴影的效果（地面不写深度）



以及，还有一个优点就是，可以把URP阴影直接砍了



**shader代码实现（仅地面）：**

```plain
//Sample DepthTex
float2 screenUV = i.screenPos.xy / i.screenPos.w + _ShadowUVBias.xy;
float4 cameraDepthTex = SAMPLE_TEXTURE2D(_CameraDepthTexture,sampler_CameraDepthTexture,screenUV);
float depthTex = Linear01Depth(cameraDepthTex,_ZBufferParams);
float4 shadowColor = (1 - depthTex) * _ShadowColor + depthTex;
```



不过因为需要使用深度，需要使用RenderObject改变背景板（地面）的渲染顺序，让它在所有不透物体绘制完以后渲染（还能顺便减少Overdraw），并且在它之前要插入一个自定义的CopyDepth Pass以获取深度



另：

![](https://cdn.nlark.com/yuque/0/2024/png/45354151/1730813964034-8794e124-7195-47ee-ba1e-4105e6176283.png)

炮台也是不透物体，会画深度，但又不希望有投影，因为它所处高度较高，通过在shader深度计算中增加一个阈值，将深度值大于阈值的部分剔除即可



完成



**瑕疵：**

因为UV是基于屏幕空间UV做了偏移，因此在屏幕边缘会存在一定的拉丝现象，不过实际游戏中不特别关注的话实际无感

