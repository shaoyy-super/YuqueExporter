基于一个基本的PBR Metallic Roughness光照模型修改

贴图导出通道：

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725003911084-34b31d58-ff62-4e04-812c-73af2b937fcb.png)

代码结构：

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725879019814-5eb003a9-df6e-4919-af56-0735fb1488cb.png)

##### 前置阅读：
![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725333600821-bb154407-f690-4fb7-911b-e24b592c79d5.png)![](https://cdn.nlark.com/yuque/0/2024/jpeg/45145007/1725333665172-846f883f-b2ef-473e-813b-855a330a661a.jpeg)

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725503722862-de4603d4-08e1-4a65-afcb-d15e7fe1998b.png)

[【PBR】 理解笔记 & Unity URP 各向异性 shader - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/477489052)

[图形学基础|各项异性与头发渲染_各向异性渲染-CSDN博客](https://blog.csdn.net/qjh5606/article/details/118117176)

[【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/69380665)

<font style="color:rgb(77, 77, 77);">丝绸尼龙类的衣服，表面比较光滑，由光滑的细丝缝制，和头发的质地有相同之处，是一种会产生各向异性镜面高光（Anisotropic highlighting）的布料，</font>

![](https://cdn.nlark.com/yuque/0/2024/jpeg/45145007/1725334293412-48489044-5fec-430a-88de-2c11fedaa489.jpeg)

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725334251352-9ac71543-108b-493f-9771-92a0dda1280e.png)

<font style="color:rgb(77, 77, 77);">各向异性（英文名称：anisotropy）是指材料在各方向的力学和物理性能呈现差异的特性。晶体的各向异性即沿晶格的不同方向，原子排列的周期性和疏密程度不尽相同，由此导致晶体在不同方向的物理化学特性也不同，这就是晶体的各向异性。亦称“非均质性”。物体的全部或部分物理、化学等性质随方向的不同而各自表现出一定的差异的特性。即在不同的方向所测得的性能数值不同。对图像来说各向异性就是在每个像素点周围四个方向上梯度变化都不一样，滤波的时候我们要考虑图像的各向异性对图像的影响，而各向同性显然是说各个方向的值都一致，常见的图像均值或者高斯均值滤波可以看成是各向同性滤波</font>



本例使用12年提出各向异性GGX高光函数计算高光

```plain
float D_GGXaniso( float ax, float ay, float NoH, float XoH, float YoH )
{
	float a2 = ax * ay;
	float3 V = float3(ay * XoH, ax * YoH, a2 * NoH);
	float S = dot(V, V);

	return (1.0f / PI) * a2 * Pow2(a2 / S);
}
```

<font style="color:rgb(77, 77, 77);"></font>

##### 直接光部分：
参考UE做法

<font style="color:black;">修改原函数的D项V项：</font>

<font style="color:black;">V项函数：</font>

```plain
float Vis_SmithJointAniso(float ax, float ay, float NoV, float NoL, float XoV, float XoL, float YoV, float YoL)
{
	float Vis_SmithV = NoL * length(float3(ax * XoV, ay * YoV, NoV));
	float Vis_SmithL = NoV * length(float3(ax * XoL, ay * YoL, NoL));
	return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
}
```

添加变量Anisotropy控制各向异性高光

添加输入参数X（切线）Y（副切线）用于计算



原BRDF：

<font style="color:blue;">float3</font><font style="color:darkmagenta;"> BRDF</font><font style="color:black;">( </font><font style="color:blue;">float3</font><font style="color:black;"> DiffuseColor, </font><font style="color:blue;">float3</font><font style="color:black;"> SpecularColor, </font><font style="color:blue;">float</font><font style="color:black;"> Roughness, </font><font style="color:blue;">float3</font><font style="color:black;"> N, </font><font style="color:blue;">float3</font><font style="color:black;"> V, </font><font style="color:blue;">float3</font><font style="color:black;"> L,</font><font style="color:blue;">float3</font><font style="color:black;"> LightColor,</font><font style="color:blue;">float</font><font style="color:black;"> Shadow)</font>

<font style="color:black;">{</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> a2 = </font><font style="color:darkmagenta;">Pow4</font><font style="color:black;">( Roughness );</font>

<font style="color:black;"></font><font style="color:blue;">float3</font><font style="color:black;"> H = </font><font style="color:darkmagenta;">normalize</font><font style="color:black;">(L + V);</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> NoH = </font><font style="color:darkmagenta;">saturate</font><font style="color:black;">(</font><font style="color:darkmagenta;">dot</font><font style="color:black;">(N,H));</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> NoV = </font><font style="color:darkmagenta;">saturate</font><font style="color:black;">(</font><font style="color:darkmagenta;">abs</font><font style="color:black;">(</font><font style="color:darkmagenta;">dot</font><font style="color:black;">(N,V)) + 1e-5);</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> NoL = </font><font style="color:darkmagenta;">saturate</font><font style="color:black;">(</font><font style="color:darkmagenta;">dot</font><font style="color:black;">(N,L));</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> VoH = </font><font style="color:darkmagenta;">saturate</font><font style="color:black;">(</font><font style="color:darkmagenta;">dot</font><font style="color:black;">(V,H));</font>

<font style="color:black;"></font><font style="color:blue;">float3</font><font style="color:black;"> Radiance = NoL * LightColor * Shadow * PI;</font>

<font style="color:black;"></font>

<font style="color:black;"></font><font style="color:blue;">float3</font><font style="color:black;"> DiffuseTerm = </font><font style="color:darkmagenta;">Diffuse_Lambert</font><font style="color:black;">(DiffuseColor) * Radiance;</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> D = </font><font style="color:darkmagenta;">D_GGX_UE4</font><font style="color:black;">( a2, NoH );</font>

<font style="color:black;"></font><font style="color:blue;">float</font><font style="color:black;"> Vis = </font><font style="color:darkmagenta;">Vis_SmithJointApprox</font><font style="color:black;">( a2, NoV, NoL );</font>

<font style="color:black;"></font><font style="color:blue;">float3</font><font style="color:black;"> F = </font><font style="color:darkmagenta;">F_Schlick_UE4</font><font style="color:black;">( SpecularColor, VoH );</font>

<font style="color:black;"></font><font style="color:blue;">float3</font><font style="color:black;"> DirectLighting = DiffuseTerm + SpecularTerm;</font>

<font style="color:blue;"></font><font style="color:blue;">return</font><font style="color:black;"> DirectLighting;</font>

<font style="color:black;">}</font>

<font style="color:black;"></font>

修改后：

float3 SlikBRDF( float3 DiffuseColor, float3 SpecularColor, float Roughness,float Anisotropy,

					float3 N, float3 V, float3 L,float3 X,float3 Y,float3 LightColor,float Shadow)

{

	float <font style="color:#74B602;">Alpha</font> = Roughness * Roughness;

	float a2 = Alpha * Alpha;

把a2拆开，拆出中间变量Alpha

<font style="color:#74B602;">	float ax = max(Alpha * (1.0 + Anisotropy), 0.001f);</font>

<font style="color:#74B602;">	float ay = max(Alpha * (1.0 - Anisotropy), 0.001f);</font>

用Alpha* (1.0 - Anisotropy)并限制范围得到GGX高光对应的ax（切线）和ay（副切线）



	float3 H = normalize(L + V);

	float NoH = saturate(dot(N,H));

	float NoV = saturate(abs(dot(N,V)) + 1e-5);

	float NoL = saturate(dot(N,L));

	float VoH = saturate(dot(V,H));



	<font style="color:#74B602;">float XoV = dot(X,V);</font>

<font style="color:#74B602;">	float XoL = dot(X,L);</font>

<font style="color:#74B602;">	float XoH = dot(X,H);</font>

<font style="color:#74B602;">	float YoV = dot(Y,V);</font>

<font style="color:#74B602;">	float YoL = dot(Y,L);</font>

<font style="color:#74B602;">	float YoH = dot(Y,H);</font>

<font style="color:#74B602;"></font>

得到D项GGX高光对应的NoH,XoH,YoH

V项对应的NoV,NoL,XoV,XoL,YoV,YoL



	float3 Radiance = NoL * LightColor * Shadow * PI;

	float3 DiffuseTerm = Diffuse_Lambert(DiffuseColor) * Radiance;

<font style="color:#74B602;">	float D = D_GGXaniso(ax,ay,NoH,XoH,YoH);</font>

替换原D项计算高光函数使用各项异性高光

<font style="color:#74B602;">	float Vis = Vis_SmithJointAniso(ax,ay,NoV,NoL,XoV,XoL,YoV,YoL);</font>

替换原V项

	float3 F = F_Schlick_UE4( SpecularColor, VoH );

	float3 SpecularTerm = ((D * Vis) * F) * Radiance ;

	float3 DirectLighting = DiffuseTerm + SpecularTerm;

	return DirectLighting;

}



初步得到丝绸材质各项异性高光

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725340214703-207514e6-8c94-4701-b729-bf73f098c491.png)



使各项异性高光受到法线影响：

添加变量_NormalAniso影响切线和副切线



         half3 tangentTS = normalize(NormalTS.x * half3(0, 0, 1) * _NormalAniso + half3(1, 0, 0));

切线本来是(1, 0, 0)，用法线的<font style="color:rgb(77, 77, 77);">x*影响变量_NormalAniso去影响切线的向量值</font>

         half3 T = normalize(mul(tangentTS,TBN));

再转换到世界空间

         T = NormalizeNormalPerPixel(T);



         half3 bitangentTS = normalize(NormalTS.y * half3(0, 0, 1) * _NormalAniso + half3(0, 1, 0));

         half3 B = normalize(mul(bitangentTS,TBN));

         B = NormalizeNormalPerPixel(B);

副切线同理

使用修改后的切线和副切线计算各项异性高光，使其受到法线影响

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725340304585-ddf786e1-6ad8-431c-a9a3-eb3c8cd58b2c.png)





##### 间接光部分：
修改原IBL镜面反射函数

做法搬运自:[Physically Based Rendering in Filament (google.github.io)](https://google.github.io/filament/Filament.html#materialsystem/clothmodel)



原IBL：

	half3 R = reflect(-V,N);

	R = RotateDirection(R,EnvRotation);

	half3 SpeucularLD = GlossyEnvironmentReflection(R,WorldPos,Roughness,Occlusion);

	half3 SpecularDFG = EnvBRDFApprox(SpecularColor,Roughness,NoV);

	float SpecularOcclusion = GetSpecularOcclusion(NoV,Pow2(Roughness),Occlusion);

	float3 SpecularAO = AOMultiBounce(SpecularColor,SpecularOcclusion);

	float3 IndirectSpecular = SpeucularLD * SpecularDFG * SpecularAO;



修改后：

修改IBL的R分量实现各项异性效果

与直接光同理添加参数Anisotropy和B和T



      float3 anisotropicDirection = Anisotropy >= 0.0 ? B : T;

各项异性方向 小于0用T，大于0用B

      float3 anisotropicTangent = cross(anisotropicDirection, V);

与视线叉乘得到新的切线

      float3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);

新的切线叉乘各项异性方向得到新的被各项异性影响的法线

      float3 bentNormal = normalize(lerp(N, anisotropicNormal, abs(Anisotropy)));

插值得到新的<font style="color:#74B602;">bentNormal</font>



	half3 R = reflect(-V,<font style="color:#74B602;">bentNormal</font>);

替换新的bentNormal

	R = RotateDirection(R,EnvRotation);

	half3 SpeucularLD = GlossyEnvironmentReflection(R,WorldPos,Roughness,Occlusion);

	half3 SpecularDFG = EnvBRDFApprox(SpecularColor,Roughness,NoV);

	float SpecularOcclusion = GetSpecularOcclusion(NoV,Pow2(Roughness),Occlusion);

	float3 SpecularAO = AOMultiBounce(SpecularColor,SpecularOcclusion);

	float3 IndirectSpecular = SpeucularLD * SpecularDFG * SpecularAO;



##### 根据需求继续修改：
原需求：类似丝绸的材质，带各向异性高光。有高光跟过度两层，能调整范围和颜色。



把原Anisotropy拆成Anisotropy0和Anisotropy1

添加AnisotropyColor0和AnisotropyColor1控制两层各项异性高光颜色

继续修改BRDF函数

把原各项异性高光拆为两层SpecularTerm1和SpecularTerm2

分别由Anisotropy0和Anisotropy1计算

最后直接光 = 漫反射 + 各项异性高光1+ 各项异性高光2

DirectLighting = DiffuseTerm + SpecularTerm1 + SpecularTerm2;



多了一个高光处理能量守恒

	float Scaling = 1.0 - max(max(_AnisotropyColor0.x,_AnisotropyColor0.y),_AnisotropyColor0.z) ;

        DiffuseTerm *= Scaling;

        SpecularTerm2 *= Scaling;

由于高光值很大，当_AnisotropyColor0颜色偏亮时会分走大量漫反射的值

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725442324904-8bbf425e-f72c-49d6-8aff-48cc5d703612.png)

高光1颜色（1，1，1）

导致：

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725442309107-051bbf1c-0883-4ab1-b76e-722148b9b86f.png)

采用把两道高光都除2的方法维持总高光强度

float3 DirectLighting = DiffuseTerm + SpecularTerm1/2 + SpecularTerm2/2;

```plain
float3 SlikBRDF( float3 DiffuseColor, float3 SpecularColor, float Roughness,float Anisotropy0,float Anisotropy1,float4 _AnisotropyColor0,float4 _AnisotropyColor1,
					float3 N, float3 V, float3 L,float3 X,float3 Y,float3 LightColor,float Shadow)
{
	float Alpha = Roughness * Roughness;
	float a2 = Alpha * Alpha;

	float ax = max(Alpha * (1.0 + Anisotropy0), 0.001f);
	float ay = max(Alpha * (1.0 - Anisotropy0), 0.001f);

	
	float ax2 = max(Alpha * (1.0 + Anisotropy1), 0.001f);
	float ay2 = max(Alpha * (1.0 - Anisotropy1), 0.001f);

	float3 H = normalize(L + V);
	float NoH = saturate(dot(N,H));
	float NoV = saturate(abs(dot(N,V)) + 1e-5);
	float NoL = saturate(dot(N,L));
	float VoH = saturate(dot(V,H));

	float XoV = dot(X,V);
	float XoL = dot(X,L);
	float XoH = dot(X,H);
	float YoV = dot(Y,V);
	float YoL = dot(Y,L);
	float YoH = dot(Y,H);

	float3 Radiance = NoL * LightColor * Shadow * PI;
	
	float3 DiffuseTerm = Diffuse_Lambert(DiffuseColor) * Radiance;


	float D = D_GGXaniso(ax,ay,NoH,XoH,YoH);
	float Vis = Vis_SmithJointAniso(ax,ay,NoV,NoL,XoV,XoL,YoV,YoL);
	float3 F = F_Schlick_UE4( SpecularColor, VoH );

	float D2 = D_GGXaniso(ax2,ay2,NoH,XoH,YoH);
	float Vis2 = Vis_SmithJointAniso(ax2,ay2,NoV,NoL,XoV,XoL,YoV,YoL);

	float3 SpecularTerm1 = ((D * Vis) * F) * Radiance*_AnisotropyColor0.rgb ;
	float3 SpecularTerm2 = ((D2 * Vis2) * F) * Radiance *_AnisotropyColor1.rgb;

	//能量守恒
	//float Scaling = 1.0 - max(max(_AnisotropyColor0.x,_AnisotropyColor0.y),_AnisotropyColor0.z) ;
	//DiffuseTerm *= Scaling;
	//SpecularTerm2 *= Scaling;

	float3 DirectLighting = DiffuseTerm + SpecularTerm1/2 + SpecularTerm2/2;
	return DirectLighting;
}
```

间接光同理

```plain
void DirectLighting_float(float3 DiffuseColor, float3 SpecularColor, float Roughness,float _Anisotropy0,float _Anisotropy1,float4 _AnisotropyColor0,float4 _AnisotropyColor1,
						float3 WorldPos, float3 N, float3 V,float3 X,float3 Y,
								out float3 DirectLighting)
{
	DirectLighting = half3(0,0,0);
	#ifndef SHADERGRAPH_PREVIEW
	#if defined(_MAIN_LIGHT_SHADOWS_SCREEN) && !defined(_SURFACE_TYPE_TRANSPARENT)
	float4 positionCS = TransformWorldToHClip(WorldPos);
    float4 ShadowCoord = ComputeScreenPos(positionCS);
	#else
    float4 ShadowCoord = TransformWorldToShadowCoord(WorldPos);
	#endif
	float4 ShadowMask = float4(1.0,1.0,1.0,1.0);
	//主光源
    half3 DirectLighting_MainLight = half3(0,0,0);
    {
        Light light = GetMainLight(ShadowCoord,WorldPos,ShadowMask);
        half3 L = light.direction;
        half3 LightColor = light.color;
        half Shadow = light.shadowAttenuation;
        DirectLighting_MainLight = SlikBRDF(DiffuseColor,SpecularColor,Roughness,_Anisotropy0,_Anisotropy1,_AnisotropyColor0,_AnisotropyColor1,N,V,L,X,Y,LightColor,Shadow);
    }
    //附加光源
    half3 DirectLighting_AddLight = half3(0,0,0);
    #ifdef _ADDITIONAL_LIGHTS
    uint pixelLightCount = GetAdditionalLightsCount();
    for(uint lightIndex = 0; lightIndex < pixelLightCount ; ++lightIndex)
    {
        Light light = GetAdditionalLight(lightIndex,WorldPos,ShadowMask);
        half3 L = light.direction;
        half3 LightColor = light.color;
        half Shadow = light.shadowAttenuation * light.distanceAttenuation;
        DirectLighting_AddLight += SlikBRDF(DiffuseColor,SpecularColor,Roughness,_Anisotropy0,_Anisotropy1,_AnisotropyColor0,_AnisotropyColor1,N,V,L,X,Y,LightColor,Shadow);
    }
    #endif

    DirectLighting = DirectLighting_MainLight + DirectLighting_AddLight;
	#endif
}

void IndirectLighting_float(float3 DiffuseColor, float3 SpecularColor, float Roughness,float Anisotropy0,float Anisotropy1,
							float3 WorldPos, float3 N, float3 V,half3 T,half3 B,
							float Occlusion,float EnvRotation,out float3 IndirectLighting)
{  
	
     IndirectLighting = half3(0,0,0);
	#ifndef SHADERGRAPH_PREVIEW
	float NoV = saturate(abs(dot(N,V)) + 1e-5);
	//SH
	float3 DiffuseAO = AOMultiBounce(DiffuseColor,Occlusion);
	float3 RadianceSH = SampleSH(N);
	float3 IndirectDiffuse = RadianceSH * DiffuseColor * DiffuseAO;

	//IBL
	float3 anisotropicDirection = Anisotropy0 >= 0.0 ? B : T;
    float3 anisotropicTangent = cross(anisotropicDirection, V);
    float3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);
    float3 bentNormal = normalize(lerp(N, anisotropicNormal, abs(Anisotropy0)));

	half3 R = reflect(-V,bentNormal);
	R = RotateDirection(R,EnvRotation);
	half3 SpeucularLD = GlossyEnvironmentReflection(R,WorldPos,Roughness,Occlusion);
	half3 SpecularDFG = EnvBRDFApprox(SpecularColor,Roughness,NoV);
	float SpecularOcclusion = GetSpecularOcclusion(NoV,Pow2(Roughness),Occlusion);
	float3 SpecularAO = AOMultiBounce(SpecularColor,SpecularOcclusion);
	float3 IndirectSpecular = SpeucularLD * SpecularDFG * SpecularAO;
	//IBL2
	float3 anisotropicDirection2 = Anisotropy1 >= 0.0 ? B : T;
    float3 anisotropicTangent2 = cross(anisotropicDirection2, V);
    float3 anisotropicNormal2 = cross(anisotropicTangent2, anisotropicDirection2);
    float3 bentNormal2 = normalize(lerp(N, anisotropicNormal2, abs(Anisotropy1)));

	half3 R2 = reflect(-V,bentNormal2);
	R2 = RotateDirection(R2,EnvRotation);
	half3 SpeucularLD2 = GlossyEnvironmentReflection(R2,WorldPos,Roughness,Occlusion);
	half3 SpecularDFG2 = EnvBRDFApprox(SpecularColor,Roughness,NoV);
	float SpecularOcclusion2= GetSpecularOcclusion(NoV,Pow2(Roughness),Occlusion);
	float3 SpecularAO2 = AOMultiBounce(SpecularColor,SpecularOcclusion2);
	float3 IndirectSpecular2 = SpeucularLD2 * SpecularDFG2 * SpecularAO2;

		//能量守恒
	//float Scaling2 = 1.0 - max(max(IndirectSpecular.x,IndirectSpecular.y),IndirectSpecular.z) ;
	//IndirectDiffuse *= Scaling2;
	//IndirectSpecular2 *= Scaling2;

	IndirectLighting = IndirectDiffuse + IndirectSpecular/2+IndirectSpecular2/2;
	#endif
}
```



得到两层高光分别控制方向和颜色

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725345795213-159509de-b489-4d55-a1c0-56e271611128.png)

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725345813776-438e8f1e-2c6c-48a9-8e85-d01e9183260d.png)



##### 加入亮片噪点效果：
直接搬运

[voronoi图生成多边形实现](https://snh48group.yuque.com/org-wiki-snh48group-ec9yge/wxfe39/pkt27mr5r63x8fn0)

使用消耗较低的函数生成，也可以采用其他方案

得到彩色亮片效果

![](https://cdn.nlark.com/yuque/0/2024/png/45145007/1725442716665-b017a538-f062-46b9-be42-4f48a4d52cdb.png)

##### 参数列表：
BaseMap 主贴图

BaseColor 主颜色

AnisotropyColor0 各项异性高光颜色0

AnisotropyColor1 各项异性高光颜色1

Anisotropy0 各项异性高光0，范围（-1，1），小于0产生会水平方向高光，大于0会产生竖直方向高光

Anisotropy1各项异性高光1

Metallic Map 金属度贴图

Metallic 金属度

Specular 高光强度

Roughness Map 粗糙度贴图

Roughness 粗糙度

NormalAniso 法线的各项异性强度

Normal Map 法线贴图

Normal 法线强度

Flakes Map  亮片的颜色贴图

EnvRotation  环境光角度

Roughness0 亮片粗糙度0

Roughness1 亮片粗糙度1

FlakesScale 亮片数量

FlakesAngle 亮片角度

OcclusionMap AO贴图

OcclusionStrength AO强度

