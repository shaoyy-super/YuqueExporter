<font style="color:rgb(51, 51, 51);">如何在运行时从脚本构建 MagicaCloth 组件</font>

#### <font style="color:#DF2A3F;">步骤</font>
1. <font style="color:rgb(51, 51, 51);">生成 MagicaCloth 组件</font>
2. <font style="color:rgb(51, 51, 51);">设置参数</font>
3. <font style="color:rgb(51, 51, 51);">开始创建和运行布料数据</font>

#### <font style="color:rgb(51, 51, 51);">BoneCloth 示例（1）</font>
```csharp
void SetupHairTail_BoneCloth()
{
  if (character == null)
    return;

  var obj = new GameObject("HairTail_BoneCloth");
  obj.transform.SetParent(character.transform, false);

  // add Magica Cloth
  var cloth = obj.AddComponent<MagicaCloth>();
  var sdata = cloth.SerializeData;

  // bone cloth
  sdata.clothType = ClothProcess.ClothType.BoneCloth;
  sdata.rootBones.Add(gameObjectContainer.GetGameObject("J_L_HairTail_00_B").transform);
  sdata.rootBones.Add(gameObjectContainer.GetGameObject("J_R_HairTail_00_B").transform);

  // setup parameters
  sdata.gravity = 3.0f;
  sdata.damping.SetValue(0.05f);
  sdata.angleRestorationConstraint.stiffness.SetValue(0.15f, 1.0f, 0.15f, true);
  sdata.angleRestorationConstraint.velocityAttenuation = 0.6f;
  sdata.tetherConstraint.distanceCompression = 0.5f;
  sdata.inertiaConstraint.particleSpeedLimit.SetValue(true, 3.0f);
  sdata.colliderCollisionConstraint.mode = ColliderCollisionConstraint.Mode.None;

  // start build
  cloth.BuildAndRun();
}
```

<font style="color:rgb(51, 51, 51);">SerializeData 类包含可以从脚本中操作的所有参数</font>

<font style="color:rgb(51, 51, 51);">BuildAndRun（） 在最后执行。  
</font><font style="color:rgb(51, 51, 51);">这将在线程中创建布料数据，并在完成后自动开始模拟。</font>

#### <font style="color:rgb(51, 51, 51);">BoneCloth 示例（2）</font>
```csharp
void SetupFrontHair_BoneCloth()
{
  if (character == null || frontHairSource == null)
    return;

  var obj = new GameObject("HairFront_BoneCloth");
  obj.transform.SetParent(character.transform, false);

  // add Magica Cloth
  var cloth = obj.AddComponent<MagicaCloth>();
  var sdata = cloth.SerializeData;

  // bone cloth
  sdata.clothType = ClothProcess.ClothType.BoneCloth;
  sdata.rootBones.Add(gameObjectContainer.GetGameObject("J_L_HairFront_00_B").transform);
  sdata.rootBones.Add(gameObjectContainer.GetGameObject("J_L_HairSide2_00_B").transform);
  sdata.rootBones.Add(gameObjectContainer.GetGameObject("J_L_HairSide_00_B").transform);
  sdata.rootBones.Add(gameObjectContainer.GetGameObject("J_R_HairFront_00_B").transform);
  sdata.rootBones.Add(gameObjectContainer.GetGameObject("J_R_HairSide2_00_B").transform);
  sdata.rootBones.Add(gameObjectContainer.GetGameObject("J_R_HairSide_00_B").transform);

  // Normal direction setting for backstop
  sdata.normalAlignmentSetting.alignmentMode = NormalAlignmentSettings.AlignmentMode.Transform;
  sdata.normalAlignmentSetting.adjustmentTransform = gameObjectContainer.GetGameObject("HeadCenter").transform;

  // setup parameters
  // Copy from source settings
  sdata.Import(frontHairSource, false);

  // start build
  cloth.BuildAndRun();
}
```

<font style="color:rgb(51, 51, 51);">在此示例中，参数是从另一个外部布组件“frontHairSource”导入的，这简化了参数设置。</font>

<font style="color:rgb(51, 51, 51);">“normalAlignmentSetting”是手动设置的，因为它无法导入</font>

#### <font style="color:rgb(51, 51, 51);">BoneCloth 示例（3）</font>
```csharp
void SetupRibbon_BoneCloth()
{
  if (character == null || string.IsNullOrEmpty(ribbonPresetName))
    return;

  var obj = new GameObject("Ribbon_BoneCloth");
  obj.transform.SetParent(character.transform, false);

  // add Magica Cloth
  var cloth = obj.AddComponent<MagicaCloth>();
  var sdata = cloth.SerializeData;

  // bone cloth
  sdata.clothType = ClothProcess.ClothType.BoneCloth;
  sdata.rootBones.Add(gameObjectContainer.GetGameObject("J_L_HeadRibbon_00_B").transform);
  sdata.rootBones.Add(gameObjectContainer.GetGameObject("J_R_HeadRibbon_00_B").transform);

  // setup parameters
  // Load presets from the Resource folder.
  // Since presets are in TextAssets format, they can also be used as asset bundles.
  var presetText = Resources.Load<TextAsset>(ribbonPresetName);
  sdata.ImportJson(presetText.text);

  // start build
  cloth.BuildAndRun();
}
```

<font style="color:rgb(51, 51, 51);">在此示例中，参数将作为预设文件（Json）导入。</font><font style="color:rgb(51, 51, 51);">参数可以以 Json 格式从外部导出</font>

#### <font style="color:rgb(51, 51, 51);">BoneCloth 中的顶点属性设置</font>
<font style="color:rgb(51, 51, 51);">可以使用 ClothSerializeData2 中的 </font>[<font style="color:rgb(0, 0, 255);">boneAttributeDict</font>](https://magicasoft.jp/en/mc2_api_clothserializedata2/#boneAttributeDict)<font style="color:rgb(0, 0, 255);"> </font><font style="color:rgb(51, 51, 51);">手动设置它。</font>  
<font style="color:rgb(51, 51, 51);">boneAttributeDict 是一个由 Transform 和属性对组成的字典</font>

```csharp
// Transform Attribute
var sdata2 = cloth.GetSerializeData2();
sdata2.boneAttributeDict.Add(bone1, VertexAttribute.Fixed);
sdata2.boneAttributeDict.Add(bone2, VertexAttribute.Invalid);
sdata2.boneAttributeDict.Add(bone3, VertexAttribute.Move);
```

#### <font style="color:rgb(51, 51, 51);">MeshCloth 示例</font>
```csharp
void SetupSkirt_MeshCloth()
{
  if (character == null || skirtPaintMap == null)
    return;

  // skirt renderer
  var sobj = gameObjectContainer.GetGameObject(skirtName);
  if (sobj == null)
    return;
  Renderer skirtRenderer = sobj.GetComponent<Renderer>();
  if (skirtRenderer == null)
    return;

  // add Magica Cloth
  var obj = new GameObject("Skirt_MeshCloth");
  obj.transform.SetParent(character.transform, false);
  var cloth = obj.AddComponent<MagicaCloth>();
  var sdata = cloth.SerializeData;

  // mesh cloth
  sdata.clothType = ClothProcess.ClothType.MeshCloth;
  sdata.sourceRenderers.Add(skirtRenderer);

  // reduction settings
  sdata.reductionSetting.simpleDistance = 0.0212f;
  sdata.reductionSetting.shapeDistance = 0.0244f;

  // paint map settings
  // *** Paintmaps must have Read/Write attributes enabled! ***
  sdata.paintMode = ClothSerializeData.PaintMode.Texture_Fixed_Move;
  sdata.paintMaps.Add(skirtPaintMap);

  // setup parameters
  sdata.gravity = 1.0f;
  sdata.damping.SetValue(0.03f);
  sdata.angleRestorationConstraint.stiffness.SetValue(0.05f, 1.0f, 0.5f, true);
  sdata.angleRestorationConstraint.velocityAttenuation = 0.5f;
  sdata.angleLimitConstraint.useAngleLimit = true;
  sdata.angleLimitConstraint.limitAngle.SetValue(45.0f, 0.0f, 1.0f, true);
  sdata.distanceConstraint.stiffness.SetValue(0.5f, 1.0f, 0.5f, true);
  sdata.tetherConstraint.distanceCompression = 0.9f;
  sdata.inertiaConstraint.depthInertia = 0.7f;
  sdata.inertiaConstraint.movementSpeedLimit.SetValue(true, 3.0f);
  sdata.inertiaConstraint.particleSpeedLimit.SetValue(true, 3.0f);
  sdata.colliderCollisionConstraint.mode = ColliderCollisionConstraint.Mode.Point;

  // setup collider
  var lobj = new GameObject("CapsuleCollider_L");
  lobj.transform.SetParent(gameObjectContainer.GetGameObject("Character1_LeftUpLeg").transform);
  lobj.transform.localPosition = new Vector3(0.0049f, 0.0f, -0.0832f);
  lobj.transform.localEulerAngles = new Vector3(0.23f, 16.376f, -0.028f);
  var colliderL = lobj.AddComponent<MagicaCapsuleCollider>();
  colliderL.direction = MagicaCapsuleCollider.Direction.Z;
  colliderL.SetSize(0.082f, 0.094f, 0.3f);

  var robj = new GameObject("CapsuleCollider_R");
  robj.transform.SetParent(gameObjectContainer.GetGameObject("Character1_RightUpLeg").transform);
  robj.transform.localPosition = new Vector3(-0.0049f, 0.0f, -0.0832f);
  robj.transform.localEulerAngles = new Vector3(0.23f, -16.376f, -0.028f);
  var colliderR = robj.AddComponent<MagicaCapsuleCollider>();
  colliderR.direction = MagicaCapsuleCollider.Direction.Z;
  colliderR.SetSize(0.082f, 0.094f, 0.3f);

  sdata.colliderCollisionConstraint.colliderList.Add(colliderL);
  sdata.colliderCollisionConstraint.colliderList.Add(colliderR);

  // start build
  cloth.BuildAndRun();
}
```

<font style="color:rgb(51, 51, 51);">在此示例中，构造了 MeshCloth，并通过</font>[<font style="color:rgb(51, 102, 255);">绘制贴图</font>](https://magicasoft.jp/en/mc2_vertexpaint/#Vertex_painting_with_textures)<font style="color:rgb(51, 51, 51);">给出了顶点属性。  
</font><font style="color:rgb(51, 51, 51);">请注意，绘制贴图与您设置的渲染器同步。换言之，渲染器和绘制贴图的数量必须相同。</font>

#### <font style="color:rgb(51, 51, 51);">MeshCloth 中直接指定顶点属性</font>
<font style="color:#DF2A3F;">与 BoneCloth 不同，必须使用 MeshCloth 明确指定顶点属性</font>

<font style="color:#DF2A3F;">两种方法：1.使用绘制贴图 2.</font><font style="color:rgb(51, 51, 51);">在 ClothSerializeData2 中使用 </font>[<font style="color:rgb(0, 0, 255);">vertexAttributeList</font>](https://magicasoft.jp/en/mc2_api_clothserializedata2/#vertexAttributeList)

<font style="color:rgb(51, 51, 51);">首先，vertexAttributeList 中的元素数量必须与 MeshCloth 中注册的 Renderer 数量匹配。</font><font style="color:rgb(0, 0, 255);">  
</font><font style="color:rgb(51, 51, 51);">其次，每个元素必须与相应渲染器中的网格顶点数量匹配</font>

```csharp
// add vertex attribute
var sdata2 = cloth.GetSerializeData2();
var attributes = new VertexAttribute[VertexCount];

// Initialize with movement attributes
for(int i = 0; i < VertexCount; i++)
  attributes[i] = VertexAttribute.Move;

// Making a specific vertex a fixed attribute
attributes[0] = VertexAttribute.Fixed;
attributes[7] = VertexAttribute.Fixed;
attributes[21] = VertexAttribute.Fixed;

// Registering vertex attributes
sdata2.vertexAttributeList.Add(attributes);
```

