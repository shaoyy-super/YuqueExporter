# 一.简述
基于优化初始包体的需求，考虑将部分AB资源拆分出去，跟据玩家游戏进度，自动或者玩家主动点击下载，补全剩余资源。



# 二.前置概念：ABPath
现行AB包划分如下图

根据RuleApplyType，一个文件夹或者一个文件，会打包为一个ABItem，然后可能会产生多个子包或者变体。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041480496-990c6535-3c3c-4d1b-beb2-b432fd9b4e6f.png)

对于边玩边下这种上层功能来说，在划分资源模块时，不应考虑子包或者变体这一层，而应该根据OneDir或者OneFile来选取。

根据Rule，可以得到一组会产生ABItem的路径(DirPath/FilePath)，这个路径可能会因为变体或者拆分子包，产生多个实际AB，但在逻辑上已经是不可再分的资源合集单位。

<font style="color:#DF2A3F;">在后续，称这样的路径为：ABPath</font>



# 三.基础思路
## 1.方案讨论
**1.1 资源分级**

优点：资源划分为L0，L1，L2，初次划分后，后续维护方式相对简单，不易出错

缺点：不支持模块化。玩家可能要消耗时间下载一些远超自己进度的资源，才能正常使用。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041569918-06c3371c-194c-4d2f-ba0f-a803867cf5e2.png)

**1.2 模块化下载**

Base为出包的最小资源包含量，根据功能开启，及玩家进度，选择下载不同的模块。

优点：按需下载，灵活性高。

缺点：维护起来相对麻烦。



同时，因为所有子模块资源等级相同。

如果允许互相依赖，下载先后将会影响依赖是否加载成功。

如果不允许互相依赖，所有被依赖的资源将被提升到Base，导致Base包逐渐变大（或者允许不同模块允许包含同一个资源）。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041570112-ffc1a0be-97b0-49af-9f7a-692197a8ca22.png)



考虑到不同的玩家群体/地区/网速，一个项目可能会采用有差异甚至两种截然不同的边玩边下方案。

最终方案应融合分级下载和模块化下载，允许项目完全使用其中一种方案，或者一主一辅。

甚至长期只使用分级，在未来突然有模块下载的需求时，能够无缝支持。



## 2.树形模块依赖结构
首先，引入模块概念。

模块(module)是一组ABPath的合集。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041701153-5cfc8cbf-18b7-4e19-b308-94be320e1105.png)

通过parentModuleName，单向的将模块连接为树。

BaseModule为根节点，为出包的必要模块。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041701321-ff0ca7fb-aaf5-4d5f-aaa3-5bc978c848b3.png)



除了BaseModule跟随包体，其它模块都可以下载获取，也可以选择跟包出（包内自带模块应是一个包含BaseModule的完整子树）。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041701466-5e056143-14cb-4bac-88d2-6da3a8a20c09.png)



模块包含的ABPath不具备互斥性质，即允许一个ABPath出现在多个模块里。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041701344-d54d3a82-f670-44b1-a66d-d6211ecda0e1.png)



节点中的所有AB，只能依赖父级节点（包括父级的父级）的中AB

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041701485-7cc04ac8-b44f-4138-b3f5-c2bfa41db706.png)



## 3.编辑器下数据组织
**3.1 模块增删改**

应提供一个编辑器窗口，支持对Module进行增删改，并提供前往选取其包含ABPath的入口按钮：

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041940441-c61fd818-e15e-4d22-8319-897963492686.png)



下图为ABPath的可选择列表，用于为模块选取其所包含的ABPath：

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041940709-664d1a37-1f4c-4093-ba95-ad83da323eb9.png)

因为BaseModule是其它所有模块的父级，已经在BaseModule中的ABPath，不应再出现在普通模块的ABPath选取列表内。

同理，已经在父级（包括父级的父级）选中的ABPath，不应再出现在子模块的ABPath选取列表内



**3.2 rule指定module**

rule新增targetModuleName（string）<font style="color:rgb(16, 18, 20);">属性</font>，当有值时，该rule产生的所有ABPath自动进入对应module。

1.主要考虑到很多Rule产生的ABPath只能进BaseModule。(除此之外，BaseModule也像普通模块一样支持手动选取)

2.其次，将来如果有一个庞大的玩法模块A时，可以有自己资源根路径，并为其添加一组targetModuleName为moduleA的Rule。

对于重量级的，大的模块，应保持资源的独立性，不依赖除BaseMoudle外的任意模块。尽量依赖Rule的拆分来划分模块，而非手动选取。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041940710-003031e9-8edc-43ad-bc5b-35c16c776fd5.png)



**3.2树修改**

考虑到运行时管理，除非整包更新，否则只允许在上一次的基础上新增模块节点，不允许删除模块，不允许修改树的层级结构。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740041940678-2083afd9-19bb-4ad5-a5ca-67e1743669a4.png)

任何情况下，不去代码强行修改或修正ABPathList，它只和人类的勾选行为有关。



## 4.打包时处理
打包时，按下列顺序进行数据处理：



<font style="color:rgb(16, 18, 20);">1.存在一个默认模块，当某个</font>ABPath<font style="color:rgb(16, 18, 20);">未被任意一个模块所包含时，加入该模块。</font>

    - <font style="color:rgb(16, 18, 20);">降低配置难度，当项目的选择偏向于分级下载时，默认模块应该是等级最高的模块。</font>
    - <font style="color:rgb(16, 18, 20);">避免手动划分产生遗漏。</font>



2.具有强依赖性的ABPath，应在此时自动进行选取。

如选取一个单位时，应根据配置，预制体，TML依赖，自动去选取其依赖的序列帧，BGM，技能场景等ABPath。



3.手动划分模块后，如果某个模块依赖了非父节点（甚至是依赖子节点）中的ABPath，应将被依赖ABPath提升至共同父级模块，或将被依赖ABPath加入此模块，修正与模块树结构相矛盾的依赖关系。

如下图，D模块依赖了E模块中的一个ABPath，此时有两个选择：

+ 提升该ABPath进入共同父级
+ D模块中也加入该依赖的ABPath（建议，因为这样不会使父模块不合理的增大）

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740042118913-57b3a250-bd81-4522-9f22-447d5dc7df52.png)



4.如果模块依赖的ABPath，不在树中任一节点模块中，应将该ABPath加入此模块，至此能够保证模块资源的完整性。

此规则与上面第1条冲突，没有被手动划分在树里的ABPath，到底是放<font style="color:rgb(16, 18, 20);">默认模块，还是放依赖它的其它模块里。</font>

<font style="color:rgb(16, 18, 20);">可以根据以下两个关键点决策：</font>

+ <font style="color:rgb(16, 18, 20);">默认模块的完整性，即默认模块是不是也依赖这个ABPath</font>
+ <font style="color:rgb(16, 18, 20);">默认模块是不是自己模块的父级</font>



5.为了使数据简明，父级（包括父级的父级）中有的ABPath，应从子节点中去除。



6.结合本次打包的子包拆分和变体情况，将ABPath列表转化为ABNameList



7.添加记录文件LocalModuleList.json，其记录了所有的模块的信息：

模块是不是在包内，模块之间的父子关系，模块中包含哪些AssetBundle

![LocalModuleList.json存放该对象数组](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740042118948-b71367ef-e228-408c-919d-8814d4603947.png)



## 5.运行时管理
1. 每次启动下载最新的RemoteModuleList，与本地LocalModuleList对比，下载LocalModuleList中已下载模块中的新增AB，删除的AB不处理。
2. 在运行时，已经完全下载的模块，追加至LocalModuleList，下次启动时仅对LocalModuleList中存在的AB包进行热更新。

如下图，仅更新BaseMudule，A，D，下载了一半的C不应进行更新（或者进行更新并补全）

下载了一半的模块应该存放在一个暂存区，只有所有AB完全下载好，再移入正常的AB加载路径。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740042350283-4ff7084c-333b-4b1d-8a86-f7e86626a0cd.png)

3. 下载应采用多线程+限速，考虑复用热更使用的下载器。
4. 在父级节点下载完成前，不允许下载子节点（或者下载完成之后不能移入AB路径，因为其可能缺少依赖）
5. 点击下载时，如果从启动到点击这段时间远端文件有更新，应调用重新启动，并在下次启动时下载触发该流程的模块。（防止AB版本不一致带来依赖错误）
6. 如果一个模块中的所有AB，都跟随其它模块下载成功，该模块即认为下载成功。

# 四.捕鱼项目接入
## 4.1现存AB分析
以下，对基本资源进行标红，并给出现在的大小。[]标识表示是一个数组。

<font style="color:rgb(243, 50, 50);">1.Shader 3.9MB</font>

<font style="color:rgb(243, 50, 50);">2.AudioMixer 4.5KB</font>

<font style="color:rgb(243, 50, 50);">3.Se 10MB</font>

<font style="color:rgb(243, 50, 50);">4.ConfigAsset(Configurable Enum) 3.5KB</font>

<font style="color:rgb(243, 50, 50);">5.font_pub 3.6MB</font>

<font style="color:rgb(243, 50, 50);">6.font_lang 36.3MB - 66.9MB</font>

<font style="color:rgb(243, 50, 50);">7.font_lang_mat 28KB - 786KB</font>

8.ModuleRes(<font style="color:rgb(218, 51, 48);">common187KB</font>+ [other])

<font style="color:rgb(243, 50, 50);">9.[Sce_Login]</font>

<font style="color:rgb(243, 50, 50);">10.[Sce_Public]</font>

11.[Sce_Main]

12.[Sce_Skill]

13.[Sce_UI]

14.[Atlas]

15.[Pet]

<font style="color:rgb(243, 50, 50);">16.pet_public 2.8MB</font>

17.[BGM]

18.[DynamicUnit]炮台？15个共5.8MB

<font style="color:rgb(243, 50, 50);">19.TimeLine 100KB</font>

<font style="color:rgb(243, 50, 50);">20.fx_ani + fx_mat + fx_prefab + fx_mesh(5.8MB) + fa_texture(26MB) 33MB</font>

21.[Collection]一些单位道具模型

22.<font style="color:rgb(243, 50, 50);">fishmatrix 38KB</font>

22.[Auido_Unit]

23.[AudioLang(guide)]

24.[PetSequence]

## 4.2模块树形图
根据现在的策划案需求，考虑如下图的方案进行模块组织：

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740042459857-27f6ce68-8cff-4764-8106-3b088420372d.png)

1. 红色部分所在Rule标记为BaseModule<font style="color:rgb(16, 18, 20);">，再加上手动选取的一些common资源，登录资源，新手场景，引导语音等，预计最小可以控制在200MB左右（仅AB）。</font>
2. <font style="color:rgb(16, 18, 20);">将一些拆分出去之后有明显优化意义（要大）的模块另起模块，并将其父级设置为DefaultModule。</font>
3. <font style="color:rgb(16, 18, 20);">其它资源不用管，全数落尽DefaultModule。</font>

## 4.3添加机制辅助手动划分
<font style="color:rgb(16, 18, 20);">黑色部分中，</font>AudioLang目前只有新手引导语音，可以考虑将其标红。

如果选中一个Pet的ABPath，在打AB包时，可以考虑将该PetABPath强关联的其它ABPath加入到对应模块，如对应的PetSequence，Auido_Unit，Sce_Skill，ModuleRes，BGM

Collection目前看是一些被TML挂载的模型预制体资源，可以考虑根据Pet的TML依赖关系，自动的将tml依赖的CollectionItem加入最终ModuleFileList。

## 4.4手动选取考虑范围
渔场模块考虑Pet，BGM

<font style="color:rgb(16, 18, 20);">非渔场模块，需要考虑</font>ModuleRes，Sce_UI，BGM， Atlas

简单的UI界面，只考虑ModuleRes和Atlas即可





# 五.最小化Module
## 5.1问题分析
上述方案中，Module拆分是在ABPath的层级上考虑的，是AssetBundle更上一层的概念，而非是Asset。

这个选择使得我们将问题量级简化，因为ABPath的数量，远远大于Asset数量的数量。

而缺点就是，因为思考的层级过高，粒度过大，导致其无法对AssetBundle的分包产生影响，不能修正不合理的ABPath。比如BaseModule仅引用一个ABPath中很小的一个Asset，但不得不将整个AB都放进BaseModule，从而包体不能最小化。

## 5.2理想方案
以下内容我们讨论，在方案的可行性与精确性之间做取舍。尝试在ABPath的概念基础上，尝试添加一些辅助机制，自动的将ABPath拆分子包。

如下图，最完美的情况是，一个ABPath根据被拆成多个AssetBundle，每个AssetBundle中仅存在对应模块依赖的Asset

但是问题在于

1. 我们很难去通过一种机制，找到Module与对应Asset之间的关系。不论是手动挑选划分，或者重新规划资源路径，还是自动记录，都很难做到在复杂业务环境下，完整准确的找到模块与Asset的对应关系。
2. 难以保持稳定的分包结果。
3. AB粒度可能会过小

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740394770411-cde71861-486f-495f-980a-17014e12c582.png)



## 5.3可行方案
现在我们主要看向BaseModule，目标变更为有效控制最小包的大小。



BaseModule理论上为最小包流程需要的Asset，BaseModule内包含的AB数量，大小，决定了最小包的大小。

有两个原因导致其包含一些最小包流程不需要的Asset

1. 最小包完全不使用该ABPath，因为其是全局通用性资源，因为有多个子模块依赖，将其划分在BaseModule
2. 最小包仅使用该ABPath中的部分Asset



为了能够保持BaseModule的最小化，我们必须有一个收集机制，能够收集到一段游戏流程内，获取所有主动，或者因为被依赖而加载的Asset。因为通常最小包的流程固定，而且较短，所以收集最小包流程的Asset列表是可能的。

在现行的资源管理框架中，可以考虑在LoadAsset() 的实现中，做这件事情。



如何保证一段流程所依赖的Asset一定搜集完整？

这个没有完美的办法，尤其是一些与随机相关的Asset，比如鱼随机播放哪个动作。

最保险的方式就是：LoadAsset接口记录+代码自行读表并记录+手动补充记录。同时尽量缩短流程的长度，避免因流程分支过多，导致记录的不完整。



假如上个流程顺利，我们得到了完整的最小包使用的Asset列表（MiniAssetList），接下来我们考虑如何拆分：

第一种，我们将ABPath中的Asset，按照是否在MiniAssetList，拆成两个：<font style="color:#74B602;">ABPath</font>，<font style="color:#DF2A3F;">ABPath_Base</font>。

第二种，我们将ABPath中不在MiniAssetList的的Asset还维持在原包，在MiniAssetList里的单个文件进行打包：<font style="color:#74B602;">ABPath</font>，<font style="color:#DF2A3F;">ABPath_AssetA，ABPath__AssetB，ABPath__AssetC</font>......

第三种，我们将包含MiniAssetList中任一Asset的ABPath整个炸成按文件划分的最小包：<font style="color:#74B602;">ABPath_AssetD</font>，<font style="color:#74B602;">ABPath_AssetE,  </font><font style="color:#DF2A3F;">ABPath_AssetA，ABPath__AssetB，ABPath__AssetC</font>......



关于这三种拆分方式，并无本质区别。方向上从第一种到第三种，越来越易用简单，方便维护，因为Asset概念逐渐等于了AssetBundle概念，可以少考虑一层，但要付出一些AssetBundle数量增多的代价。



不管怎么拆分，接下来要做的事情都一样。

如下图，在<font style="color:#DF2A3F;">BaseModule</font>下面动态的插入一个模块节点：<font style="color:#74B602;">CommonModule</font>，将最小包流程不使用的AssetBundle从<font style="color:#DF2A3F;">BaseModule</font>移到<font style="color:#74B602;">CommonModule</font>。

<font style="color:#74B602;">CommonModule</font>必须在其它任意模块下载前进行下载。

![](https://cdn.nlark.com/yuque/0/2025/png/43256925/1740393980218-280376a2-f88d-4d18-b527-b59df13400eb.png)



基于以下两个机制，做出如下表的更新处理方式：

1. 不管使用哪种分法，在后续更新时，要遵守一个原则。即要保持与出包时的拆分结果一致，否则会导致AB依赖关系发生变化，从而牵动一些不必要的AB变更。
2. 由于我们每次进游戏，都会对LocalModuleList中已下载的模块进行更新，所以BaseModule支持在后续更新时，追加新的AssetBundle进去。

| 初包时Asset在不在MiniAssetList | 当前包Asset在不在MiniAssetList | 划分结果 |
| --- | --- | --- |
| Yes | Yes | 维持初包分包结果，进BaseModule |
| No | No | 维持初包分包结果，进CommonModule |
| Yes | No | 维持初包分包结果，进CommonModule |
| No | Yes | 维持初包分包结果，进BaseModule |


## 
# 六.问题讨论
1. <font style="color:rgb(16, 18, 20);">Rule规则发生变化/文件路径进行调整/ABPath重命名，Rule删除，都会影响已经分好的模块。这个可能有还未考虑到的风险。</font>
2. <font style="color:rgb(16, 18, 20);">对模块进行手动ABPath选取，遗漏是一个可能出错的点。尤其是通过对应功能的配置表进行资源加载，配置表修改，资源模块无法感知。</font>

<font style="color:rgb(16, 18, 20);">可以考虑用GM开始/结束，监控内部AB加载，获取一段时间（充分时长）内，哪些AB被加载了。</font>

<font style="color:rgb(16, 18, 20);">或者每个模块都实现一个接口，来自行读配置表，并将结果输出给资源模块。</font>

3. <font style="color:rgb(16, 18, 20);">一些畸形的引用关系可能会导致最终结果与手动选取的结果有很大差异，发生提升时，应给出提示，使人类有修正的机会。</font>



