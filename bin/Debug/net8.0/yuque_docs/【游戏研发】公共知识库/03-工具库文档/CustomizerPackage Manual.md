# 一.功能简介
CustomizerPackage是一个提供了捏人/捏脸/换装的工具包，其内部基本不包含资源，为纯粹的代码功能实现，其内部有以下内容：

+ 运行时捏人/捏脸/换装的相关实现
+ <font style="color:#DF2A3F;">为换装定义excel的配置资产结构</font>
+ <font style="color:#DF2A3F;">针对美术的配置资产编辑工具</font>

此手册可帮助您了解上述内容中，最后两个部分的使用细节，及功能实现的大概思路，以便于您更好的使用本工具包。

此手册适合功能程序/美术/策划阅读，您可以从头到尾阅读该手册，或将其用作参考。



# 二.什么是配置资产
对于一般的游戏业务，配置资产通常指由策划编辑的excel文件，用于让策划在一定程度上控制游戏业务的内容。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726283778138-533eba83-785a-4b89-96a1-4f5d4926fe74.png)



对于捏人捏脸来说，excel是不合适的，因为此时我们需要美术来方便的编辑并预览效果。

所以在CustomizerPackage中，我们定义了类型：CustomizeData，该类型的实例即为配置资产。

CustomizeData是一个继承自ScriptableObject的资产类型，内部序列化了版本号，以及所有捏人+捏脸+染色的配置数据。

![CustomizeData实例对象](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726284189520-577d3c32-eac5-4847-8816-0f874592c97a.png)



# 三.捏脸
## 简述
捏脸从功能和实现上来说，分为5个部分：塑形，妆容（眼妆/眉毛/腮红/唇彩/面纹），皮肤，眼球，睫毛。

## 配置资产
对于捏脸来说，配置资产里的内容有：

+ BlendShape的变形范围

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726194018340-77187c52-1862-43c1-88b3-08814a1bb7d2.png)



+ 妆容/睫毛/眼睛/皮肤的预设列表，及其调整参数的默认值，及调整范围。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726194111094-d81fab08-3c85-42e0-b13d-0a79b86dbe81.png)

## 捏脸配置资产编辑工具
我们使用CustomizeDataModifier来作为捏脸配置数据的编辑和预览工具。

它的作用是提供GUI，让美术方便的编辑CustomizeData资产对象，在非运行时即时的预览到捏脸效果。

它继承自MonoBehaviour，我们为此组件提供了特殊的Inspector实现，用于在非运行时，对捏脸配置资产对象进行编辑，并即时预览。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726123132796-fe957a62-1d60-4d88-913d-adb7a9b8c8c4.png)



打开示例工程中的FaceEditor场景，选中F_000_Editor，就可以看到它的Inspector面部，如下图所示，美术在此编辑捏脸配置资产。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726195534341-e9dea2af-dcfd-4cd9-a22a-5ffe7faa5a14.png)



在CustomizeDataModifier的Inspector的OnEnable中，如果捏脸数据为空。程序会自动的在Define.C.DefaultPluginFolder（默认Assets/CustomizerDemo）下的Config文件夹下新建CustomizeData资产对象（{裸模预制体名}_customize.asset），作为默认的数据资产对象。



faceBlend和localication可以直接使用示例工程中提供的。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726196112729-1ddb42ff-4620-4172-81eb-90b4da80543d.png)

![变形器命名翻译中文的辅助资产文件](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726123198227-733f195e-90a6-4ede-8360-e2983f21c5a4.png)

## 塑形
塑形使用SkinnedMeshRenderer的BlendShapes来实现，它是一种通过设置对应数值来影响模型顶点位置的工具。BlendShapes由美术制作，决定了BlendShape影响哪些顶点，如何影响顶点。

我们使用它，来让面部的形状可以得到调整，已达到不同的脸型。

![BlendShapes](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726285710440-7f39de1d-a448-4041-a65e-bc87566c914a.png)



对于CustomizerPackage来说，我们需要给每一个BlendShape设置数值范围，避免用户将脸部调整为极度的不合理状态。因此在“面部塑形”页签，我们提供了BlendShape的预览和上下限设置功能。

![滑动滑条以预览效果](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726125010204-dfcae12d-a34e-4488-b022-e4908a7ab782.png)



| ![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726196617573-c05258af-001b-4247-91ae-fe13587449bf.png) | ![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726196634044-b4a3b22a-52fe-4772-a94a-7c0e440f5550.png) |
| --- | --- |




展开后，滑动上部滑条，并点击Min或者Max按钮用以设置此变形器最大值和最小值，这是一个会导出的范围数据，用以记录美术允许用户能在多大的范围内调整这个变形器：

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726125059599-f1b4b96d-f9f9-4783-9e63-08146d494431.png)



批量设置所有变形器的最大值和最小值：

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726125169752-9d266122-cf3c-4fdf-9571-91c300141097.png)

## 妆容
妆容分为5个部分：眉妆，眼妆，唇妆，腮红，面纹

妆容的实现可理解为向面部追加贴图，每个妆容的资产配置包含一张贴图，及默认的颜色/位置/旋转/缩放信息，和位置/旋转/缩放的调整范围。

![妆容编辑分类](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726290784126-07fa7fa1-0183-45b0-81c5-482c9acf1bae.png)

我们以下将使用眉妆举例，来说明妆容素材编辑面板的使用：

我们将详细的介绍眉妆的编辑面板，从上到下，分为5个部分。

![美妆编辑](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726290933175-d496c3a3-e4ac-4fd2-9223-51f2378b3452.png)



第一部分：为眉毛这个分组类型的中文命名和枚举，枚举牵涉到导表时id生成，需保证正确。

![第一部分](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726291283301-49fdf9c6-9258-4fb6-aa21-56173a3cf01d.png)



第二部分：

第二，三，四部分，显示的是第5部分选中的素材的克隆体。

纹理编号：眉装素材的唯一标识，由美术命名，需保持唯一

添加设置：如果纹理编号不在素材列表里，则添加一套素材。反之，会将克隆体的数据 覆盖到 纹理编号对应素材

纹理：眉毛的主贴图

UV位移：纹理在脸上横向和纵向的位置偏移的初始数据。(用户滑杆从0到1，此值表示滑杆0.5时的位置偏移量)

旋转：纹理在脸上横向和纵向的旋转初始数据。(用户滑杆从0到1，此值表示滑杆0.5时的旋转值)

缩放：纹理在脸上横向和纵向的旋转初始数据。(用户滑杆从0到1，此值表示滑杆0.5时的旋转值)![第二部分](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726291721717-e6c96489-ee53-461c-967a-4c6f46ceb7c5.png)



第三部分：

第二部分提到，纹理素材可以设置默认的/基础的/原始的/用户滑杆为0.5时的位移旋转缩放（后续称之为基础值）。第三部分则是用于配置，用户可以在我们的基础值之上，允许位移旋转缩放的范围。

![第三部分](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726292828746-f520e629-3f67-4494-a45e-670c5adeea04.png)

横向移动：如下图，在UV位移处，我们配置了基础值的X位置偏移为1，在下图右下角，有一个偏移值为5，以及一个设置按钮。数值5表示左右移动范围，设置按钮点击后，程序会做一个简单的加减法，并更新范围的最小值和最大值。如下图中 “-4 = 1 - 5”，“6= 1 + 5”，所以用户的滑杆0到1时，眉毛的x偏移为-4到6。

![范围设置](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726292912771-897a494f-17cb-4588-a545-2147b2cfd7ea.png)

纵向移动/旋转/横向缩放/纵向缩放同上，不再赘述。



设置选中：将上述的五个范围数据，保存到当前纹理编号对应的素材内

设置所有：将上述的五个范围数据，保存到所有纹理编号对应的素材内



第四部分：

选中"使用颜色通道"后，将会出现三个颜色选框，反之则只有1个。

这是因为，虽然我们每个素材只有一张纹理，但我们可以设置多个颜色，每个颜色影响不同的纹理区域。

Tips：

眉妆：支持1个颜色，透明度有作用

眼妆：支持3个颜色，透明度都有作用

腮红：支持3个颜色，颜色1的透明度有作用

面纹：支持1个颜色，透明度有作用

唇妆：支持1个颜色，透明度有作用

![第四部分](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726293620197-3e03ad97-bd3a-47f1-9129-47580ef9606c.png)

注意，第四部分的颜色数据有些特殊，我们认为，眉毛需要一个初始颜色，但不需要每个眉毛有不同的初始颜色，所以在此处调整好颜色后，点击设置颜色按钮，将会更改所有眉毛的初始颜色默认值。事实上，这五种妆容的颜色都是如此的设计。



眉妆增加修改流程示例：

1.输入要添加的眉妆的编号，确保不与已有眉妆重复

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294277348-b657f341-2791-4d5d-a620-a78b712eca65.png)

2.点击添加设置

如下图，将命名编号增加1，再点击添加设置按钮即可完成添加

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294357452-da1ba7e2-52a8-4dac-97a4-f2e3e65c28a1.png)

3.设置纹理，设置后场景中可以即时预览

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294476536-3b57c894-2eda-4a25-8594-0b91a5f3c9ef.png)

4.调整基础值

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294588994-98cdc5a7-76bc-450c-b351-b10cdce4ff7a.png)

5.设置范围，手动修改这5个数字到合适的值

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294647613-2c980a18-f059-460d-94d9-cf24b79574ff.png)

6.点击设置按钮，使上一步设置范围，应用到最大值和最小值上

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294691862-229f9aa5-f5c3-4ff3-b572-2c2805f7a8ab.png)

7.移动滑杆，观察场景中的变化范围是否符合预期。如果不符合，跳转到第5步。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294760905-aa76e840-1105-417b-bb9d-384a09d6e305.png)

8.颜色。颜色一般不需要修改，所有的眉毛用相同的初始颜色。不过此处可以拖动色盘，预览脸的变化，只要不点击设置颜色按钮，这个调整是不会保存下来的。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294827032-b4824728-b51e-4baa-89f8-2c967505c287.png)



9.保存

点击添加设置

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294954952-40f17a36-5f41-4e12-a68a-c9b34241cd0a.png)

选择确定

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294973177-fd33ff84-2cbd-4b47-8237-2472ade6c275.png)



10.修改已有素材，直接从第3步开始

11.删除

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726294935848-e58f9bac-b120-4bc9-99b9-dcdc67c1aa94.png)







## 睫毛
睫毛编辑面板和妆容编辑面板的操作逻辑相同，保存修改机制相同。

此处介绍一下只介绍一下新出现的，float数值默认值及范围。

如下图，上滑杆的逻辑与上文BlendShape处的相同，程序会给这个滑杆设置一个能支持的最大上下限，但有时，美术不希望用户有这么大的调整范围。此时可以滑动上滑杆，点击min按钮和max按钮，设置允许用户操作的范围。下滑杆滑动可以预览效果，同时也代表了这个数值的默认值。

我们将这种有（上限，下限，默认值）的三个数字的组合，称为一个Shader数值属性调整器，后文中，将多次出现。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726295673328-fe912863-3911-40ca-ad58-6fd3ac2d4605.png)



## 眼睛
眼睛的界面操作逻辑与保存逻辑与妆容几乎完全相同，唯一不同的是，我们认为眼睛，可能有不同的初始颜色基础值，所以，眼睛的颜色数值，也可以通过添加瞳孔按钮，并选择覆盖来保存。



眼睛有很多可调整项，但基本上只有三种类型：Texture，Shader数值属性调整器，Color，即下图的三个红框。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726296092283-8872e66e-bee5-4ec9-bfdb-eebd7b77b368.png)

## 皮肤
皮肤的操作逻辑与保存逻辑完全与眼睛一样，不再赘述。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726296437483-3976e426-02f6-42b9-8fc6-0914aa585500.png)



## 保存
点击下图中的保存按钮：

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726296513262-bca0e58d-faac-4fe7-9336-87b5508ec137.png)



然后你本次的所有修改都会被保存到下图中的文件中：

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726296555457-59588e2e-a2fb-471f-a982-d8b8d2e3448b.png)



## 导出配置excel
尽管配置资产中已经存储了捏脸所需的一切素材/范围，但它一定是需要导出为excel或者其他格式的可视化文本文件，以下是这么做的理由：

+ 引用了Texture，真机运行时依赖不便于管理
+ 策划需要一个口子，来控制这些数据的组合方式，通常会使用项目内的配置解决方案，一般为excel
+ 为了降低与业务项目间的耦合，CustomizeData内保存的所有数据均不对外暴露，避免内部实现更改时，所有使用的项目要跟着一起改。
+ 为后续的妆容类型允许业务侧扩展打下基础

导出的接口及使用示例请参见API文档，导出excel后的格式请参见Customize.xlsm

[Customize.xlsm](https://snh48group.yuque.com/attachments/yuque/0/2024/xlsm/43256925/1726297165061-9f6fddad-06ac-4a45-ad38-900d6b80e500.xlsm)



## 总结
从实现方式角度讲，我们捏脸的实现有以下几种

+ 塑形
+ Shader float数值调整，支持上下限
+ Shader color调整
+ Shader texture调整
+ 纹理的位置旋转缩放，支持上下限

对于后四项，可能都需要配置默认值，因为我们不会为不同的妆容/眼球的所有素材创建不同的材质球，所以有些值尽管可能不会暴露给用户，也需要保存并导出。

# 四.捏人
## 简述
捏人是通过SkinnedMeshRenderer实现的，它通过编辑器窗口 编辑/创建捏人部位，并将要控制的骨骼组织到目标部位里。运行时，由业务侧先行改变部位的滑条数据，并通知底层进行刷新，同时业务侧需通过接口实现提供所有部位的滑条值的访问。

## 配置资产：
详见捏人编辑器使用说明

[捏人编辑器使用说明](https://snh48group.yuque.com/org-wiki-snh48group-ec9yge/rgqlf2/fv9n6g8akkfgyoem)

对于捏人来说，它还依赖ModelDefineConfig.cs结构，对于excel如下，业务侧策划需建立名为ModelDefine的配置，并再由客户端在运行时转化为ModelDefineConfig对象。详细流程参考API文档。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726299340275-7dbaa012-4eef-4d41-9a8a-d84ae81e2972.png)





# 五.换装
## 简述
换装模块内部实现了以下功能

    - SkinMesh合并
    - 部位冲突的检测与处理
    - 服装变体机制
    - 骨骼剔除恢复/布料模拟碰撞处理
    - 4以上顶点骨骼权重支持
    - 法线计算所需数据的序列化和组织
    - 头发及衣服染色
    - 高跟鞋/手持/套装/散件混合套装等特殊类型的表现和冲突处理
    - 在挂件上再挂件
    - ...

因为考虑了比较精细的层级占用冲突规则，同时提供了变体机制，所以理论上换装系统可以支持相对比较高的换装自由度。

因为服装配置表偏向于策划组织使用，因此，换装系统有一套手动组织设计的配置表（excel）。业务侧可以用任意形式来实现这套配置，只需在运行时将其反序列化换装系统提供的对象即可。

具体思路见：

[换装美术资源方案](https://snh48group.yuque.com/org-wiki-snh48group-ec9yge/rgqlf2/qs90fb1lg09gqhnq)

## 配置数据
### 衣服主类型表
![ClothesMainType](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726131070344-a4464e00-2a91-454f-9e5d-c337356a10cd.png)

### 衣服子类型表
![ClothesType](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726131263128-7cfc98c5-160f-42d0-89fb-e3cc8b93861e.png)

### 衣服实例表
![ClothesItem](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726131294348-af36c3e7-ec2a-4a27-8edf-44ef539a0fd2.png)

### 裸模定义表
![ModelDefine](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726131346488-872decc5-5105-4706-ac2f-c71f89d23dc7.png)

### 绑点表
![ClothesBindPoint](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726131380156-5e698724-d9fd-4866-9ee1-0fadea21f17e.png)

### 配置表读取
参见API文档

### 冲突
冲突首先由ClothesMainType表的mutex_list决定，其次由ClothesType表的层级占用决定，占用了某个部位裸模的同一层，即认为冲突。

### 必要
出于人不能不穿衣服的原则，ModelDefine表的needful_clothes_list描述了哪些主类型是必需的，needful_clothes_id_list描述了这些部位的默认itemid

### 变体
ClothesMainType的childType描述了，代码将如何组织变体树。ClothesItem的sub_type_list和variant_asset_list一一对应，描述了如何该itemid由哪些变体版本的资源，分别对应哪些子类型。

上面的概念，详细的理解可以参考简述中链接的文档。

### 骨骼命名规范
对于上衣/下衣/鞋子/连衣裙/手套等需要人体骨骼蒙皮的衣服，它们具有完整的人体骨骼结构。程序实际使用时会使用程序工具剔除人体骨骼后的版本。  


![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726218452299-43221bdf-3208-45db-aeb8-c901a29fca11.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_664%2Climit_0)  
  
  
如下图，在合适的层级，加入衣服独有的骨骼，这些骨骼通常用来做布料模拟。衣服独有的骨骼，必需带上所属英文名，同时用预制体内唯一的后缀标识。  
原则是，在一个模型上同时穿上上衣/下衣/鞋子等的衣服，仍然不能有重名的骨骼。  


![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726218590673-5fbfdd1e-19f6-4782-83bd-a62cb564826d.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_1012%2Climit_0)

  
  
挂点类饰品的Root和Rotate节点，加上部位英文前缀，以此避免在挂到人体上时，污染人体的骨骼层级结构，务必注意此项要求，严重时甚至会导致人体骨骼识别失败。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726218877733-0a777152-48a8-460d-b807-d0053bb8954a.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_1012%2Climit_0)

  
 

### 骨骼剔除
一件上衣/下衣/鞋子，在进入unity时，都具有完整的人体骨骼结构，我们通过骨骼剔除工具将其剔除，并在运行时将裸模的骨骼设置给衣服。

由于骨骼剔除后，mesh不可见，材质设置/模型重新导入/布料编辑等会非常不便，于是我们将在一个不参与打包的目录对存放所有未剔除骨骼的衣服预制体，用于给美术编辑，编辑后点击刷新，即可及进行剔除骨骼，同时保留预制体上的修改。

除了骨骼剔除，点击按钮时还会计算SubMesh接缝点以便于运行时计算法线，布料组件引用的处理等。总之，美术应该完全的编辑TEMP版本的预制体，再点击刷新同步过去。

带有TEMP绿标的预制体表示此为中转版本。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726135653239-78e881cf-cb2e-4465-b5d7-a79f6a0a7320.png)



![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726153687926-17ac9a90-f1d7-40a0-940e-2ad3abd217eb.png)

在点击上图按钮时，内部做了许多事情，包括但不限于：

+ 骨骼剔除，并记录父级信息
+ 重新指定布料组件引用的碰撞框
+ 对衣服内包含的裸模部分进行Mesh接缝处顶点收集
+ 对衣服内包含的裸模部分进行UV接缝处顶点收集
+ ...

我们认为这是一个相对比较重要的时机，即将给美术使用的Prefab转化为给程序使用的Prefab。所以我们对外提供了自实现接口，业务侧实现IClothesPrefabConvertReceiver.cs后挂载，即可获得剔除前后的执行时机回调，详细参见API文档。

### 布料碰撞框设置
在穿上一件裙子时，很可能需要将腿部的布料碰撞框，设置给裙子上的布料组件。甚至在有背饰的时候，头发上的布料组件需要和背饰上的碰撞框进行碰撞检测。

我们提供ClothColliderGroup枚举来定义裸模身上不同部位的碰撞框组。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726138575516-b8571af6-f8c4-45cf-b02f-894c22007faf.png)



内部提供了针对MagicaCloth布料插件的实现，分别为ClothColliderContainer.cs和ClothColliderReference.cs

![ClothColliderContainer](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726138944008-31377c0f-e26a-4ce9-a6cd-f3ac26ad2c06.png)



![ClothColliderReference](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726139046869-ec76b9f6-edbb-4b70-8fa2-45bcaf382ae4.png)

如果业务层使用不同的布料插件，我们提供了IClothColliderContainer和IClothColliderReference接口，详细参见API文档。



### 如何制作一件衣服
1.确定主类型

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726302276065-521d9ba5-0dde-4240-8b7d-14bf5c58370f.png)



2.确定子类型

我们制作衣服时，应先确定是否有已经存在的子类型，如果有接近的，因尽量限制模型，以使其符合子类型的层级占用要求。如果确认没有，可以选择新加子类型。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726302421636-f2e696c1-2259-4c5e-aadc-fa5a27d9bb65.png)



3.将模型导入到Unity

选择人形骨架：

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726302669927-32280e80-397d-4b23-9db2-de791f963347.png)

如果业务侧需要开启4以上的骨骼权重，需更更改此处，同时更改项目工程质量设置：

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726302755680-0c4be04e-8ee4-46dc-93a1-f6852ac4dcff.png)

开启读写。建议做导入监听，对衣服所在的文件夹进行统一设置开启读写：

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726302695703-ae6cec86-ed26-436c-b913-a13f644e113a.png)

4.制作预制体，在ArtNoBuild/TempClothesModel下创建预制体，并挂载如图脚本

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726302589307-0509ea2a-4a0f-4854-bfa9-d82ca6b8c8d8.png)

5.设置材质

6.在如图位置添加节点，设置布料组件

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726302994511-2a1181bf-f837-4aac-85a1-21579e6b732d.png)

7.如果需要动画组件，请修改为如图设置

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726303061518-5fa32413-21b4-4622-afe0-bceebe2ecad4.png)

8.染色配置，详细参见本文的后续衣服染色

9.转化预制体，将会把预制体路径中的ArtNoBuild/TempClothesModel替换为Art，同步修改或者生成对应的程序使用的预制体

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726303142105-deb7fca3-2ba7-4c66-8817-e413f7dd65bc.png)



10.修改材质/布料等，跳转到第5步



11.添加配置

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726302509867-613c468c-e0b0-4444-b179-3837c7c1afc8.png)



### 头发染色
不同于前文中捏脸的克隆设定，头发染色配置在此处点击添加即可新建。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726133323734-85387870-4a1a-4e97-a639-2fc210000db7.png)



选中后，即可调整该染色配置的颜色初始值，以及一些范围值配置，修改后，点击页签分类上面的保存修改即可。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726133374222-c5f5aee9-8b99-48c5-9a9f-5719a31b48b6.png)

### 衣服染色
在此处选择并添加新的需要染色的，未剔除骨骼的衣服预制体。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726133735585-2b4782c0-0248-48f3-b8f1-7444d161a7c0.png)

如果没有特殊的需求，程序默认的将找到这个预制体下唯一一个含有可染色材质（材质命名不含"_FC"）的SkinMesh（如果有多个符合条件，不保证会取到哪一个），并查看这个材质是否有“_Mask1/2/3Color”属性，如果都有的话，就认为这个skinMesh的材质向用户提供了三个可染色区域。



在一些特殊需求下，比如染色区域分布在两个mesh上，比如只有1个或者2染色区域，添加如下图的脚本，数组的每一项都是一个染色区域，可以是任意数量的区域，每个区域需要制定是哪个skinMesh，同时指明是哪个通道需要染色。添加/刷新衣服染色配置时，程序将优先使用这个脚本上定义的配置。如果没有该组件，则使用默认的规则。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726134363723-e00e6ab3-0f9c-403f-ac52-6fb7eed96df9.png)



点击刷新即可刷新SkinMesh及通道的选中

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726134482271-242e7d85-257d-40cc-8528-132d7ce7af52.png)



当给的模型无法找到符合染色条件的材质，将会有无效标志，并在点击进行刷新时给出无效原因。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726134616477-0b3987d4-98c5-430c-a601-fd39f5f628f8.png)



### 资源共享
我们有一个设想，即允许使用CustomizerPackage的项目，或者开发团队，对衣服模型/贴图，妆容贴图资源/数据配置等，进行共享。

为此，我们将选用合适的平台，建立资源库，同时需要与各方商讨，由此带来的一系列问题的解决方案。如ID冲突，上传下载更新，版本管理，数据导入导出合并，资源预览等。对这一系列问题，我们目前仅有一个大致的思路，尚不成熟完善，需与各个CustomizerPackage使用者对此进行专项的细节讨论。

# 六.资产配置的最佳实践
经过以上对捏脸/捏人/换装的相关美术工具介绍，我们再次回到配置资产CustomizeData。

<font style="color:#DF2A3F;">1个CustomizeData资产对象，足以记录1个裸模的所有捏人/捏脸/染色数据。（裸模指原始模型，通常数量很少，比如男模/女模）</font>



但是，由于一些原因，在此建议将1个裸模的CustomizeData资产对象拆分为最少两个，甚至更多。比如分为两个，一个放捏人数据，一个放捏脸和染色数据。后续我们将会考虑细分资产配置类型，使用更多的类型代替CustomizeData，并提供转化工具，以便于更加符合每个功能的特性。



以下是建议依据或原因：

+ 捏脸会引用Texture/Prefab资产，捏人则是纯数据。
+ 捏脸/染色的配置数据将会导出文本，由业务层运行时解析使用，捏人则是将资产数据传入即可。
+ 妆容/染色数据有可能在多个裸模间复用，捏人数据完全跟人体裸模一一对应。
+ 多人协作时，不同的人分别负责捏人/捏脸/染色，如果不分开，很可能会有文件冲突



也就是说我们<font style="color:#DF2A3F;">一个裸模所有的数据都用CustomizeData这个类型来序列化，用多个实例存放不同数据的方式来区分用途。</font>

如下图，是我们的使用示例，命名中的"f_000"代指我们的女性裸模，“body”/“face”表示这个资产对象用于存放哪些数据。

![](https://cdn.nlark.com/yuque/0/2024/png/43256925/1726124073326-5ad59804-fb4f-4478-8e00-87034f04a353.png)



customize_face_f_000包含除捏人配置之外的所有配置数据，由于功能特性，此文件由美术编辑，内部会引用很多资产文件，如Texture/Prefab。建议不对该文件进行打bundle，而是采用编辑完成后导出成excel，接着由策划引用这个excel并配置UI组织方式。



customize_body_f_000只包含捏人配置数据，不引用任何资产，所以编辑好后，无需导出配置，运行时直接将该资产对象传入底层进行捏人控制器的初始化即可。

