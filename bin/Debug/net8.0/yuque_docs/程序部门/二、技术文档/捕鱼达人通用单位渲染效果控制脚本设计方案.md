# 一、简介
**目的**：

1. 因当前项目中，在同一个预制物上往往会需要挂多个脚本来控制单位的各种渲染效果，长期下去会导致后续效果跟进维护困难，且每个脚本需要自己维护一套逻辑，资源浪费大，所以期望用一个整合过的单位渲染效果控制脚本来统一管理各类渲染效果，封装材质接口和管理逻辑，仅需要开发具体的参数计算逻辑。
2. 之前压扁效果基本都是运行时才开启，原则上是认为压扁效果控制不会导致画面表现与未压扁产生差异，因此无需美术在非运行时编辑资源时关注未压扁的渲染效果。但考虑到实际过程中，画面表现所受影响因素过多，且也需要考虑方便排查问题这一因素，因此期望实现编辑器非运行时状态下的渲染效果预览。

**内容**：

1. 该脚本用于**统筹控制单个物体上的各类渲染效果**，主要方式以材质属性控制为主。
2. **兼容**同样改变物体材质属性的**TML材质控制**，避免两者同时工作时引起一些不方便排查的问题。
3. 支持多个物体嵌套后，由最外层物体统一控制各子物体的渲染效果，**确保父子级渲染效果一致**。
4. 支持不同**独立物体之间的渲染效果同步**。
5. 支持编辑器**非运行时**模拟运行时的**渲染效果预览**。
6. 需要优化**编辑器界面以及开发方式**，减少后续新增渲染效果控制的开发成本。

**预览**：

![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1731465326478-ccfe09c7-fb3a-4f13-bc3b-87237518325b.png)

![](https://cdn.nlark.com/yuque/0/2024/png/1660870/1731465396834-7f427208-a04f-46ec-9be1-1a3a9fb45026.png)



# 二、结构设计
**内容**：

:::tips
1. **GlobalMatCtrl** - 单例，运行时、非运行时都执行。用于记录全局渲染控制参数，如是否开启效果预览，全局相机参数, 是否绘制Gizmos等。
2. **PerObjMatCtrl** - 单个物体上的渲染控制脚本，用于记录单个物体的渲染控制参数，封装具体的控制实现逻辑，抽象出方便调整的参数计算单元。
3. **PerObjMatCtrlEditor** - 对应单个物体渲染控制脚本的编辑器GUI脚本，用于优化编辑器界面，方便使用。
4. PerObjShaderAttribute 及 PerObjShaderPropDrawer - 前者是参数的自定义属性，后者是自定义属性参数在编辑器上的显示方式。二者用于标记各类新增参数，实现封装控制逻辑。

:::



# 三、详细结构设计


![画板](https://cdn.nlark.com/yuque/0/2024/jpeg/1660870/1731483064842-29a0eb68-c55d-4b4b-bfd4-7ece0853a8a3.jpeg)



内容：

:::info
1. 通用的模块：用UML类图给出全部对外接口的定义（要带参数）；如果涉及多个类或者脚本，要在类图中体现出依赖关系
2. 系统内重要的模块：用UML类图或XMind脑图给出重要数据结构定义，并且体现出模块间的依赖关系
3. 除类图、类结构的详细说明外，还应该给出功能涉及到的各种重要规则、用法的说明。

:::

目的：

:::info
1. 对重要的部分，深入思考实现细节。
2. 列出依赖关系，辅助思考设计是否合理。
3. 让其他人更直观的看到具体用法（主要是指通用的部分）

:::

注意点：

:::info
1. 通用模块，自身功能实现要完备（如：有开就要有关）。不要为了偷懒随意搞全局的东西出来
2. 通用模块，对外提供的接口要简洁易用
3. 标记依赖关系的时候，重点思考内聚、耦合问题

:::



# 四、流程设计
内容：用时序图描述模块间的交互流程；用流程图描述核心算法

目的：讲解流程。通过画图让自己思考更深入、让其他人看的更直观。



# 五、提出问题
如果存在重点、难点问题的解决方案没想清楚，可提出问题在会上讨论



---

# 六、总结整理（开发完成后撰写）
开发过程中，很可能产生跟上面方案不一致的地方。可能补充了更多的细节内容，可能由于某些未想到的原因推翻了方案中的一些设定。

所有开发完成后有价值的内容，都可以记录在这里。

