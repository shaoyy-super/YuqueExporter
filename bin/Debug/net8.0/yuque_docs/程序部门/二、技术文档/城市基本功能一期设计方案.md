### 简介：
策划文档链接：[城市文档功能拆分（一期） (yuque.com)](https://snh48group.yuque.com/cod5mf/iwqppn/niuh2ds9xg7mv9l1)

主城场景中，玩家可与NPC交互，进入功能界面。NPC头顶3DUI显示功能名字和功能图标。**点击功能图标或者NPC模型**，寻路至NPC并打开交互菜单；

![](https://cdn.nlark.com/yuque/0/2024/png/43733777/1721638753940-2a4fd2dc-1ba0-44ad-933e-d4488d8c51f9.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_943%2Climit_0)

**头顶3DUI有显示隐藏逻辑**：功能图标在超出一个较远距离（检测距离）时隐藏，名字文本的显隐距离用通用的数值

![](https://cdn.nlark.com/yuque/0/2024/png/43733777/1721626259378-eda337d1-6f81-421f-adcf-da7b38bc25e3.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_362%2Climit_0)

**2D菜单UI判定逻辑**：当玩家交互范围内有一个NPC时，直接显示当前NPC交互菜单UI；如果有多个，则**玩家镜头瞄准**的模型（类似捉宠）>交互范围内最近的1个模型>距离内其他模型



### 结构设计
这个功能是在主城场景里面的，直接用 **Page_Town_Ctrl **和 **Scene_Town_Ctrl**

新建Lua\Presentation\CSys\Town\Interactive 文件夹，用于存放交互模块的lua脚本

**lua脚本：**3Dui脚本为**UIInteractiveHud3D，**2Dui脚本为**UI_Interactive_Ctrl**，**UI_Interactive_Panel**

NPCActor_Ctrl：创建NPC单位控制器

PlayerActor_Ctrl：玩家主角单位控制器

**c#脚本：脚本路径：client\Assets\Scripts\Exts\Town**

**InteractiveCheckCtrl：**负责检测NPC3DUI和主角(相机)之间的交互距离控制3DUI显隐，脚本挂载在3DUI上

**InteractiveTargetCtrl：**挂载主角玩家碰撞体节点上，lua端(**Scene_Town_Ctrl**)注册回调，响应交互对象

UI预设放置路径：client\Assets\Art\ModuleRes\Town

**相机切换视角**：在NPC出生点虚拟相机节点下添加控制相机脚本CinemachineVirtualCamera（每个npc可配置不同相机参数），当与某个选中的NPC交互时，激活脚本。

**ColliderBoxPoint节点**放置npc的交互碰撞框，可调整不同大小

![](https://cdn.nlark.com/yuque/0/2024/png/46334471/1722844013205-4840b2a8-60a6-4027-bdd9-6492a92f6a73.png)

### Page_Town_Ctrl
1.GetPageInfo()：设置情景场景信息为Town，预加载ui table{UI_Joystick，UI_VirtualTouch，UI_Town，UI_Interactive}

2.DoPreload(param)；预加载场景资源，预创建3DUI池

2.OnShow(param)：打开主城中需要的ui

3.OnClose()：关闭主城中的ui，删除3DUI池

### Scene_Town_Ctrl
1.DoPreload()：预加载NPC，获取NPC出生坐标点（通过主城场景里面放置NPC出生点）

2.PreloadNPC()：读CityNpc配置获取load_id，PreloadActor（load_id）预加载Actor的Prefab，缓存每个点对应的npc_id

3.FindBornPoints()：获取NPC刷新点（npc_born_points）和虚拟相机节点（npc_point_camera）并缓存

4.OnShow()：在这创建玩家和NPC，添加屏幕点击检测InputMgr:AddTap

5.CreatePlayer(): 主角初始化，设置相机跟随（主角相机和npc虚拟相机），绑定刚体，交互检测脚本

6.InteractiveTargetCtrlBind(): 主角绑定刚体，交互检测脚本，设置回调

7.OnInteractiveTarget(collision_point_list，goId): 周围可交互对象回调，处理可交互列表和屏幕相机射线击中的模型

8.CheckInteractiveUIState(): 检查更新交互2Dui的状态信息，也通过当前寻路点和当前交互点判断处理主角寻路停止

9.CreateNpcs()：通过self.npc_born_points缓存的点位信息，NPCActor_Ctrl设置位置旋转等参数，actorid_point_list缓存ActorId对应的point点

10.OnTapTarget(trans，hit_point): 点击屏幕回调，返回检测到的目标transform，判断当前交互目标是否一致，不一致则寻路

11.ClickNpcBtn(point_id): 点击NPC3Dui图标响应，传入point点，判断当前交互目标点是否一致，不一致则寻路

12.ToDoFindPath(pos): 调用player_ctrl的寻路接口

13.ChangeCamera(is_npc);修改npc对应的虚拟相机接口

14.OnHide(): InputMgr:RemoveTap移除屏幕点击检测

15.OnDestroy(): 清空数据缓存

### NPCActor_Ctrl
基于ActorBase新建一个NPC的实例控制器（创建实例，初始化，是否添加寻路等）

1.OnCreateActor(npc_id)：创建模型实例，setlayer，添加3DUI

2.SetPointId(point_id)；3DUI设置对应的point点，点击3DUI图标要用到

3.OnDispose(): 清空缓存



### UIInteractiveHud3D
1.Ctor(npc_id):从池里面获取预设，然后绑定组件,设置canvas的layer

2.SetFollowTarget(actor_ctrl)：设置跟随对象，根据静态属性放置在静态节点上

3.InitUI(npc_id)：初始化ui信息，通过npc_id获取npc相关功能的icon和名字

4.SetPointId(point_id): 设置对应的point

5.OnClickBtnObj(): 判断功能是否开启，调用Scene_Town_Ctrl：ClickNpcBtn

### 
### InteractiveCheckCtrl
![](https://cdn.nlark.com/yuque/0/2024/png/46334471/1722848454737-2659376a-7a39-4ded-bdd8-ec39b6f93fb9.png)

c#脚本，脚本挂载在3D交互UI上，处理（3DUI的图标和文字显隐状态）

在Update()中，判断Vector3.Distance(transform.position, SceneCamera.transform.position)

NPC3DUI和主角（相机）之间的交互距离是否满足显示条件



### **InteractiveTargetCtrl**
在主城中，创建主角后，通过**InteractiveTargetCtrl**在lua中的回调OnInteractiveTarget(collision_point_list, goId)，**Scene_Town_Ctrl**集中管理碰撞列表collision_point_list。如果射线检测为0，则从列表中选择最近的点，如果射线检测不为0，则和对应的npc点位交互

通过触发器检测周围可交互npc列表，帅选tag，需要射线检测时，在update里面执行

如果检测到数量大于1个时，则在**InteractiveTargetCtrl脚本中**屏幕中心发射射线检测，结果传递到**Scene_Town_Ctrl脚本，对最终的交互对象做判定，判定规则：****玩家镜头瞄准**的模型（类似捉宠）>交互范围内最近的1个模型>距离内其他模型，刷新交互UI。

### UI_Interactive_Ctrl
1.OnShowUI(npc_id):  刷新交互ui显示

2.RefreshInteractiveView(npc_id):通过id找到对应的菜单选项配置，传给panel

3.OnClickFunc：切换镜头，打开功能界面

### UI_Interactive_Panel
2D菜单UI，组件绑定CompIndex，GoIndex

1.RefreshInteractiveView(icon,title):刷新界面

2.Close(): 关闭菜单按钮



### 


### 












