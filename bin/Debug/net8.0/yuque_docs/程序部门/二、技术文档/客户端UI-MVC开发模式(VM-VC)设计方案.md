# 一、简介
设计新的开发模式，核心目的是提高代码的复用性，降低功能移植的成本。同时也要兼顾如下几个方面：

+ 代码书写的规范：一致性、合理性
+ 保证规范的前提下，尽量简单易用



从需求角度，代码复用可能的形式：

+ 从A项目移植到B项目：功能逻辑基本相同，UI要完全重做（因为美术风格不同）
+ 从A系统，衍生出B系统：家的操作流程完全一样；UI的内容绝大多数地方一样，只有一些小地方会新增或者修改；服务器的匹配机制完全不同。
+ 横竖屏切换：同一个功能，随时切换两种不同的表现UI



# 二、结构设计
![](https://cdn.nlark.com/yuque/0/2024/png/43256857/1719887602405-e5384cc4-7332-4fbf-8436-9911b793ddd7.png)

### 为什么使用VM，不是C？
VM的核心是数据绑定，数据绑定只需要将数据跟UI组件建立一次绑定关系，后续的刷新不需要到处执行。

比如好友状态的显示（陌生人、请求加好友、好友、拉黑），在C的开发模式下，下面每个操作后都要写代码刷新状态：

+ 打开好友列表时，根据当前状态显示
+ 发送加好友请求后
+ 收到好友申请通过消息后
+ 收到被拉黑消息后
+ 发送拉黑请求后



### 辅助实现框架功能的工具模块
1）TraceData

可追踪数据变化，提供Diff-Patch能力的纯数据table

2）TraceDataBinder

给V或者其他关心数据变化的模块使用的绑定器。

+ 生命周期与V一致，提供一键解绑的便捷函数；
+ 支持分组绑定与按组刷新；
+ 弥补TraceData本身没有数据绑定的支持，但提供的是延迟的拉取式刷新。（不会在TD数据变化时立刻、主动推送变化）

~~3）ClickBinder~~

~~按钮等用户输入组件的事件绑定器。因为点击事件要放到V里，V又不希望做class，提供Binder来少机械的重复代码~~

+ ~~生命周期与V一致，提供一键解绑的支持~~



# 三、详细结构设计
## 1、MVC各部分的职责
### 1.1 View视图
+ 处理与Unity组件的交互全部事情，只有V可以持有Unity对象
+ 最先处理玩家输入（如点击事件），把表现层的任务做完后，回调外部的逻辑处理
+ 【ViewModel用法】向VM绑定界面刷新的函数，收到数据变化回调后，刷新对应的界面
+ 【TraceData用法】向TraceDataBinder绑定界面刷新的函数，收到数据变化回调后，刷新对应的界面
+ 对外提供刷新界面的各种接口：ShowXxx、RefreshXxx、DisplayXxx
+ 提供让外部处理用户输入的接口：BindClickXxx
+ 接收外部给定的VM（视图不应该自己直接取VM对象）：Setup(vm1, vm2, ...)



### 1.2 Ctrl控制器
+ 关联VM-V，将这二者进行组合：明确界面要使用哪些VM、使用哪个Panel，并执行Panel.Setup(vm)
+ 处理UI的生命周期、解析并处理外部的参数输入
+ 响应用户输入，<font style="color:#DF2A3F;">处理简单的逻辑任务</font>，或者某个模块特有的逻辑：如检查玩家等级是否足够（V回调给C）
+ 接收外部通知，然后调用界面刷新，如：网络消息，其他模块抛出的消息



### 1.3 ViewModel&Model模型
Model并不是每个项目都有，如果有的话Model的职责如下：

+ 发送网络请求，按服务器的需要进行参数检查（这里的逻辑不是客户端本身要关心的）（双端代码共用）
+ 接收服务器消息，刷新数据同时刷新VM，抛出客户端的广播事件

ViewModel：

+ （在没有Model的项目中，VM会直接承载Model的全部职责）
+ 处理与表现无关的业务逻辑、通用逻辑：如消耗资源时检查资源是否足够，不足的情况下通知外部弹出来源或兑换
+ 提供数据绑定的支持，当自身数据变化后，<font style="color:#DF2A3F;">延迟或隔帧通知</font>视图刷新



### 1.4 其他情况
1）通用道具的Item类，整体作为一个View，如果有需要也可以承担一部分Ctrl的职责。

因为这部分相对简单，变化也少（如果变了，大概率是MVC都要变）没必要搞很复杂的结构



## 2、核心模块结构
![](https://cdn.nlark.com/yuque/0/2024/png/43256857/1719918346754-6fa20e34-5ff5-4100-8cea-41a8e06083b5.png)

### 数量对应关系
1. 一个Panel可以持有多个不同的VM对象
2. 一个VM对象可以被多个不同的Panel使用
3. （一组特定的VM+一个特定Panel）的组合，对应一个Ctrl。特殊情况下也允许，Ctrl根据参数动态组合不同的VM与Panel
4. （若有）M与VM是多对多，常见、常用的是1对1



### TraceDataBinder分组绑定
1. 分组绑定，可以用组来代表一个局部刷新的单位，可控性更强
2. 组内每一项绑定又分两种方式：
    1. 一个字段一个处理函数：最简单的形式。比如：TxtItemCount绑定item_count字段，字段变了直接刷新Text
    2. 一组字段一个处理函数：一个展示信息，需要用到多个数据，不需要绑定多次；不需要定义多个重复的函数。如：TxtEnergy能量展示【当前能量/最大能量】，两个值都是可变的，有一个变就要刷新，两个都变也只刷新一次。
3. 用统一调用的刷新方式，处理分阶段的表现更自然
    1. 比如一个表现形式：左边先扣除养成道具，一个特效飞到右边，到达位置后属性提升
    2. 在统一的刷新函数里，结合1的分组，先刷新left_group，再播特效，再刷新right_group



# 四、流程设计
## 1、UI打开过程
这里展示UI打开时，各模块初始化需要做的事情

![](https://cdn.nlark.com/yuque/0/2024/png/43256857/1719920565645-8e15d5cd-e8a9-4502-9fd9-559202b211c7.png)



## 2、玩家操作处理过程（商店购买兑换）
这里展示，当玩家做了一个输入操作后，各模块要做的事情。

![](https://cdn.nlark.com/yuque/0/2024/png/43256857/1719921442294-0a2fe364-69cf-414e-8cd8-efc0ae7312a6.png)

这是一个比较完整的流程，涵盖了：

1. Panel收到Click，先做一个表现行为：放点击音效
2. Panel回调Ctrl，执行购买的逻辑行为
3. Ctrl收到购买行为后，先检查自己系统独有的玩家等级限制
    1. 如果检查不通过，给出通用的Hint提示
    2. 如果通过，调用VM的购买行为
4. VM收到购买行为，检查货币是否足够
    1. 如果不够，弹出通用的来源获取/或者资源购买弹窗<font style="color:#DF2A3F;"></font>
    2. 如果足够，发送网络请求给服务器
5. VM接收服务器返回消息，更新TD数据，并等到帧尾，统一提交变更，抛出全局事件
6. Ctrl监听到全局事件，调用Panel局部刷新界面。（不一定要刷新全部发生了变化的部分）
7. Panel用diff_tbl调用binder的刷新，进而通过绑定的刷新接口完成界面变更



### VM数据更新要点
1. 收到网络消息后，立刻更新TraceData，但不立刻通知Ctrl、Panel
2. 等待到帧尾/或者下一帧（需测试验证），统一将前面的所有变更广播出去。
    1. 具体做法：将自己注册到UpdateMgrEE里，等待被调用
    2. 好处1：可以天生规避数据到达有先后顺序的问题（特别是战斗里，同帧抛出多个cmd，但抛出顺序跟表现层需要的顺序不一致）
    3. 好处2：规避重复刷新。如：同一个值在不同的地方被反复修改
3. 变更广播出去前，要执行TraceData.Commit，将变更提交并得到diff_tbl，界面上只刷新diff_tbl相关的部分
    1. 因为只能执行一次Commit操作，所以广播的消息要直接带上diff_tbl，Panel的刷新接口要接收diff_tbl作为参数



## 3、Panel编码要求
目的：规范全体的书写格式，形成统一标准

1）固定的3个local变量

1. Def = {}：定义Panel里使用的常量，如：GIdx、CIdx、其他值等
2. cs：持有Component4Lua对象
3. this={}：记录要用到的各种变量，如：binder、lua_behaviour、vm

2）Panel的所有方法都不要self，也就是都通过“.”访问（为了方便各种回调）

3）Panel脚本最后必须return一个函数（为了做检查），固定写法如下：![](https://cdn.nlark.com/yuque/0/2024/png/43256857/1719926551368-6de00eb2-b364-4bae-bfe4-773b5220ea65.png)

4）Panel对象只能通过UIMgr获取访问，不再支持全局的随意使用

# 五、提出问题
为了避免过渡纠结浪费时机，下面问题的讨论仅发表两种观点：

1）提出选项外的方案

2）在给出的方案中，选择1个自己比较认可的，阐述原因

### 问1：VM中检查不通过的反馈应该如何执行？
1）直接调用HintFacade的接口

这种方式，相当于直接操作的调用了View接口，从结构设计角度是不合理的。

可能不会产生实际的问题，因为它调用的一定是通用的、简单的功能接口，而且是在UI打开的时候才会执行。

+5

2）抛通用事件出去，由其他地方进行处理

基本上只能由Ctrl来响应这个事件，那么就会产生重复代码。每个Ctrl都要写、或者调起代币不足的的处理。

3）抛事件，全局模块接收事件

+7

VM不适合做队列管理



### 问2：VM的变化是直接回调到Panel还是通知到Ctrl？
1）直接回调到Panel

+ 可以省去Ctrl的一层调用
+ VM里数据修改后，可以直接让界面刷新，不用写额外代码

+3

2）通知到Ctrl

好处同【VM数据更新要点】

不足就是缺少1）的优势，还有需要传递diff_tbl

+7

3）混合用

+3



### 问3：Panel里绑到VM里的回调，直接定义到Panel上，还是额外定义一组local的函数？
```git
1)
function UI_Demo_Panel._RefreshEnergy(val)
  cs:SetText(Def.GIdx.TxtEnergy, val)
end

2)
local ViewFunc = {}
function ViewFunc.RefreshEnergy(val)
  cs:SetText(Def.GIdx.TxtEnergy, val)
end
+7
# 强制刷新不变的值

```

![](https://cdn.nlark.com/yuque/0/2024/png/43256857/1719984114873-648993ac-442d-410e-bb63-f73ccc738fae.png)



### 问4：Model的访问范围？
M跟VM可以相互访问，配置表的读取能否被V使用？

1）V直接调用M里取配置的接口：`Bag:GetItemConfig(item_id)`

+9

2）VM进行封装转发：`BagVM:GetItemConfig(item_id) return Bag:GetItemConfig(item_id) end`

+4

