| ###### 是否有Blend | 否 |
| --- | --- |
| ###### 是否需要还原状态（记录&还原的时机） | 不需要记录初始值；<br/>还原要做，只是把自己添加上去的材质移除掉 |
| ###### 是否需要外部传入对象，要控制哪些<br/>###### (Owner、Target、Actors) | 控制常规的TML-Actor |
| ###### 轨道是自更新，还是随Track进度更新 | 随Track更新 |
| ###### 是否需要额外处理OnPause（暂停是一定要支持的） | 不需要额外处理 |
| ###### 在Clip范围外逻辑如何处理<br/>###### (取消控制，还是保持在某个状态下) | 无需支持 |
| ###### 轨道应用情景 | |
| > 给物体动态增加渲染效果<br/> | |
| ###### 轨道使用限制 | |
|  | |




## 1、功能点列表
1）节点Renderer查找

- [ ] 通过Hierarchy路径选择要控制的Renderer节点
- [ ] 节点路径为空时，查找身上的所有节点
- [ ] （考虑支持填多个节点路径）
- [ ] 提供Renderer跟SkinnedMeshRenderer的筛选【只在路径为空时有用】
- [ ] 支持查找不可见的Renderer【只在路径为空时有用】

2）其他

- [ ] 不特殊控制材质添加的位置，都放到最后
- [ ] 属性修改：Float、Color、Vector4、Texture、Keyword



## 2、设计思路
要考虑的问题：

1、Editor非运行时，要使用SetPropertyBlock修改属性，避免修改到资源本身

2、运行时要修改材质的实例，不能修改shared

3、怎样处理追加的Renderer，如单位的部位挂件

4、怎样支持LOD

5、关键字、管线功能的开关



大概思路：

1. Q1&Q2：属性修改，编辑器、运行时分为两个类，不再混一起
2. Q3：暂不处理新增的情况；删除保证不出错即可
3. Q4：不做额外处理，使用者通过不同路径自己找不同LOD的renderer。大概率不同LOD要改的材质也不同，所以不做程序上的归类。只要保证找不到LOD资源时不报错即可。
4. Q5：暂不考虑

## 3、代码结构
+ MatManageUnit
    - 材质管理单元。可以挂在角色身上，也可以挂在场景中一组节点上。它管理这一组材质的修改记录（添加、删除、修改），并可以取消修改操作
    - 【内聚】
    - 可能需要定义成接口，方便拓展、支持角色&场景的不同处理方式。先用具体类实现，做一些尝试再决定是否要用接口。
+ MaterialCollector
    - 管理一批Renderer的材质（记录原始材质、取当前材质、对材质列表的修改）
    - 【解耦、规避相互依赖】
+ PropModifier/PropBlockModifier
    - 代表一个属性修改的行为
+ KeywordModifier
    - 代表一个材质关键词的修改行为
+ MatPropValue
    - 材质属性修改的参数（类型、名字、起止值等）
+ MatPropMixerHelper
    - TML中更新属性变化的工具类，多个轨道中更新的流程一样，减少重复代码
    - 【分层管理】
+ RendererFilter
    - 将Renderer筛选的条件、操作封装到一个模块
    - 【内聚、复用】



---

## 4、迭代优化
1）修改关键字只能修改材质，编辑器如果有多单位共享材质，还是免不了赋值材质球

为了规避复制材质球导致单位Prefab出现变更的情况，发现一个简单的方式：

:::info
将Instantiate出来的材质，设置为DontSave模式，这样挂着材质的Prefab就无法保存。

如果确实需要保存Prefab，可以手动Revert被修改的MeshRenderer节点。

:::

用1个小处理+低频的手动操作，可以避免代码上做大量复杂的管理

