# 一、简介
之前项目是对属性（**attr_name**）操作（**op**），主要是**add**、**mul，**然后计算最终值

山海项目使用一套新的计算方式，基于**属性Id**来计算属性，主要分为**面板属性**和**战斗属性**两块内容



面板属性：单位的养成属性，做为进战斗的基础属性

战斗属性：进入战斗后，面板属性受到战斗里各种Buff或技能加成，最后计算出来的属性



# 二、结构设计


## 1、策划属性配置表id规则
[属性表id规则和计算方式](https://snh48group.yuque.com/cod5mf/iwqppn/oulb9n5cup37rbsn#o7F2)





**属性Id = 属性类型 * 100 + 结尾**

比如：101 = **<font style="color:#74B602;">1</font>** * 100 + 1，102 = **<font style="color:#74B602;">1</font>** * 100 + 2，103 = **<font style="color:#74B602;">1</font>** * 100 + 3  
其中 101、102 代表属性id

**<font style="color:#74B602;">1 </font>**代表 hp属性

1 代表 hp基础值，叠加也是使用这个属性id

2 代表 hp加成百分比属性1

3 代表 hp加成百分比属性2



**面板属性值** = 面板基础叠加值 * （1 + 加成百分比1）*（1 + 加成百分比2）*...*（1+加成百分比n）

**战斗属性值** = 面板属性值*（1 + 战斗加成百分比1）*（1 + 战斗加成百分比2）*...*（1+战斗加成百分比n）+ 战斗叠加值

## 2、程序主要脚本
+ BattleCalculator 属性操作类，用来管理属性的读写以及权限检测
+ BattleValue 属性计算类，用来计算属性的最终值

# 三、详细结构设计


整体结构和原来一致，原来属性的改变需要传两个字符串类型 **attr_name、op**，改成了一个整数类型**属性id**

![](https://cdn.nlark.com/yuque/0/2024/png/22817384/1721193416842-65786f73-8385-44cf-a87a-95bd63b366df.png)



# 四、流程设计


## 1、配置区别
原来的属性配置是直接配置的属性名，以及操作方式，比如增加100血量，配置是 **hp add 100**

现在配置是属性id + 数值，比如 101,151

## 2、属性操作
`BattleCalculator`和`BattleValue`对应的`AddOp`和`RemoveOp`方法第一个参数属性id

这里的id有个默认规则：

+ 小于100的属于特殊用处的属性id，不走计算公式，比如**眩晕**
+ 大于等于100的属于正常的属性id，按照属性id规则解析和计算



```plain

---@param id number 属性Id < 100认为是特殊id
function BattleValue:AddOp(id, value)
	self.ops[id] = (self.ops[id] or 0) + value
	if id >= AttrIdRatio then
		self.dirty_attrs[floor(id / AttrIdRatio)] = true
	end
end

function BattleValue:RemoveOp(id, value)
	local cur_val = self.ops[id]
	if not cur_val then
		Debug.LogError("【BattleValue】RemoveOp failed， no attrId = " .. tostring(id))
		return false
	end

	self.ops[id] = cur_val - value
	if id >= AttrIdRatio then
		self.dirty_attrs[floor(id / AttrIdRatio)] = true
	end
	return true
end
```



## 3、属性获取
这里默认返回的都是计算后的属性值，也就是说不管传入的id是 101、102还是199，最后都是获取属性 1(hp)的最终值

战斗里有特殊需求，需要获取面板最终值，第二个参数传true即可

```plain
---@param id number 属性Id
---@param is_base boolean 是否要获取面板属性值，默认都是取最终值
function BattleValue:GetAttr(id, is_base)
	if id >= AttrIdRatio then
		local attr_type = math.floor(id/AttrIdRatio)

		local base_id = attr_type*AttrIdRatio
		if is_base then
			return self.attrs[base_id] or 0
		end

		if self.dirty_attrs[attr_type] then
			--	1 是面板基础值
			local value = self.is_battle and (self.attrs[base_id] or 0) or (self.ops[base_id + BaseIndex] or 0)
			--	51 是战斗叠加值，战斗叠加值需要额外加到最后
			local add_value = self.is_battle and self.ops[base_id + BaseIndex + BattleOffset] or 0
			--	从 2 或者 52 开始计算叠乘
			local from_id = base_id + (self.is_battle and BattleOffset or 0) + BaseIndex
			local mul = 1
			for i = from_id + 1, from_id + MulCount do
				mul = mul * ((self.ops[i] or 0) / AttrRatio + 1)
			end
			value = (value * mul + add_value) / AttrRatio
			self.cached[attr_type] = value
			self.dirty_attrs[attr_type] = false
		end

		return self.cached[attr_type] or 0
	else
		return self.ops[id] or 0
	end
end
```



~~特殊属性ID不做缓存标记，直接获取（已修改）~~

## 4、属性转换


计算所有属性类型对应的最终值，返回给战斗使用，在这里要设置一下**最大血量属性id**



```plain
-- 将所有有效属性，都转换为一个基础Table返回
function BattleCalculator:All2BaseTable()
    local attrs = self.base_data:CurAttrValues()
    if not attrs[MaxHpId] then
       attrs[MaxHpId] = attrs[HpAttrId]
    end
    return attrs
end
```



```plain
---@return table<number, number> 只返回属性列表的最终值
function BattleValue:CurAttrValues()
    local rst = {}
    for id, _ in pairs(self.dirty_attrs) do
       if id < AttrIdRatio then
          local base_id =  id * AttrIdRatio
          rst[base_id] = self:GetAttr(base_id)
       end
    end
    return rst;
end
```



## 5、属性获取方式


```plain
--region ========= TODO 兼容字符串读取属性，临时接口，改动太多，跑通后，逐步查找替换 =========
local function _CheckAttrId(id)
    if type(id) == "string" then
       if id == "max_hp" then
          return MaxHpId
       end
       local attr_base_id = SkillConfig:GetAttrId(id)
       if not attr_base_id then
          Debug.LogError("不支持属性【"..id.."】")
          return 0
       end
       id = attr_base_id*AttrIdRatio
    end

    return id
end
--endregion

---@param t BattleCalculator
BattleCalculator.__index = function(t, key)
    local rst = BattleCalculator[key]
    if rst then return rst end

    key = _CheckAttrId(key)

    if key == HpPercentId then
       return math.floor(t.base_data:GetAttr(HpAttrId) / t.base_data:GetAttr(MaxHpId))
    elseif key == LoseHpId then
       return math.floor(t.base_data:GetAttr(MaxHpId) - t.base_data:GetAttr(HpAttrId))
    elseif key == HpAttrId or key == MaxHpId then
       return math.ceil(t.base_data:GetAttr(key))
    else
       return t.base_data:GetAttr(key)
    end
end
```



策划统一一下接口，固定的接口

# 五、问题


1、（程序相关）AddOp里直接记录属性id的值，GetAttr里遍历属性id即可（已处理）



2、（程序相关）特殊属性，比如眩晕等，使用100以下的属性id（已处理）



3、属性加成，有基于某一个属性id的值去计算的吗？

比如战斗内，血量叠加值，基于面板加成值去计算



<font style="color:#DF2A3F;">目前策划只会获取面板最终值，不会获取其他的属性叠加或者叠乘的数值</font>



4、战力计算问题



+ <font style="color:#DF2A3F;">面板属性按照计算后的最终值，根据属性表对应的战力计算</font>
+ <font style="color:#DF2A3F;">还有一个非面板值的技能战斗力计算，待策划补充</font>



5、策划配置表上，还需要最终计算值这个id吗，后缀是0和50这两个id



<font style="color:#DF2A3F;">策划是不需要的，只是程序用来计算的一个特殊属性</font>



6、最后计算的伤害值浮动，是在扣除护盾前计算，还是扣除护盾后计算？

比如最终伤害值是 1000，护盾是600，最后是拿1000计算，还是扣除护盾后，拿400去计算



<font style="color:#DF2A3F;">先计算伤害浮动，再减护盾</font>



7、hit_frame2的计算，是直接加？



<font style="color:#DF2A3F;">算成固定伤害值，不受其他的任何加成</font>



8、脚本调用的伤害，算到哪个流程？

 时机有问题，应该放到更早的计算伤害之前处理

<font style="color:#DF2A3F;">策划调用的属性修改，也是基于属性id去操作</font>



9、关于技能或战斗单位的特殊标记，打算用哪种方式去做？

目前有以下几种：

+ <font style="color:#DF2A3F;">用Buff叠加层数</font>
+ ~~增加一个BlackBoard功能，策划自己去计数~~
+ ~~按照特殊属性Id处理（用这种方式需要考虑特殊id的区间，不要和属性id冲突，因为计算方式不一样）~~



~~10、拆分出来一个属性表~~



11、战斗中修改生命上限



<font style="color:#DF2A3F;">策划要补充一个规则文档，确认一下计算方式</font>

<font style="color:#DF2A3F;"></font>

<font style="color:#0C68CA;">方案如下：</font>

<font style="color:#0C68CA;">血量百分比加成：不允许直接修改叠乘属性id，应该先获取当前血量，计算好需要加的生命值，添加到血量属性上</font>

<font style="color:#0C68CA;">最大血量百分比：新加一个属性id，直接操作属性id，修改后，程序保证当前血量百分比不变，需要特殊处理一下当前血量值</font>

---

# 六、总结整理






