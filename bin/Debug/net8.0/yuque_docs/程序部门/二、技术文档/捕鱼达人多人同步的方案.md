# 同步相关流程的设计方案




目前的同步我们采用一些类似帧同步的思路

## 1.新增概念RoomTime时间轴的概念
这个相当于服务端的一个游戏开始的时间轴的概念，客户端第一次进入房间后设置时间戳，后续则各开始各自计时，客户端所有的逻辑update中的时间采用这个时间来进行相关的运算



举例：

a.比如客户端在进入房间后1s的时候有生成鱼逻辑，比如某个逻辑中update 核心代码应该

Float endtime = Roomtime.time + 1, 后续通过判定Roomtime.time的时间是否大于endtime 来继续相关逻辑的计算，而不是采用unity的时间



b.如果对应的逻辑中有时间间隔相关运算，可以适当补偿逻辑运算的次数，以同步效果

比如子弹生成逻辑，假设时0.3s生成一个，如果某个update产生卡顿，导致后续的Roomtime.deltaTime的时间差远远超过1s，此时子弹生成运算次数应为3次，而不是1次，注意逻辑的补充





RoomTime 这个类和UnityEngine.Time 这个类差不多



UML类图

![](https://cdn.nlark.com/yuque/0/2024/png/49784329/1730093193574-1eedf1d4-b808-4305-9150-0531a5df86b1.png)



房间的时间原则上不进行暂停和缩放，特殊功能除外



1.有了这个时间和随机数，来确定客户端<font style="color:#c00000;">产生的路径是确定的</font>，<font style="color:#00b050;">甚至同步一些操作的时间戳，客户端下次update时，计算时补充逻辑的运算次数，来达到运算结果一致</font>。

2.多人同步，只需要考虑第一次初始化的时候，同步时间以及随机值种子，不需要实时同步位置，减少同步数据量。  


## 2.类似ECS的思路，将功能模块分离，自行驱动Update，实现各个子系统的暂停逻辑
### *为什么要这么改
a.目前各个系统的暂停逻辑同步都是特殊处理的代码，比较混乱

以下摘自GameControl.cs

```csharp
void Update()
{
    if (!IsFreezing)
        RoomLifeTime += Time.unscaledDeltaTime;
}
```

b.目前数据同步期间，逻辑和表现没有拆分，在场景加载的时间段内很容易出现BUG

c.支持拓展，比如后期可能策划会有技能系统或者Buff系统又或者停止某个单位的时间



### *为什么不直接使用ECS
改动较大



把项目中的各种管理器，继承基类SystemBase, SystemBase有2个重要的属性，一个time，一个update，来实现部分系统的暂停逻辑。



### **拿目前的移动改进举例**
渔场道具的使用，可以考虑BattleMgr,停止了MoveSystem而不是把整个房间的时间暂停。

时序图

![](https://cdn.nlark.com/yuque/0/2024/png/49784329/1730096497408-e19a44a3-a8b0-41c1-8753-efcc413f8b4f.png)  


*注意停止时间的操作要用时间戳，<font style="color:#DF2A3F;">为了消除客户端帧时间的误差，个系统update发现超过时间戳之后，需要进行赋值，强行拉动时间，而不是</font><font style="color:red;">进行时间的叠加操作</font>

*个子系统时间则为系统运行时间

*以上代码实现均在BattleMgr 统一处理，子系统无感知

对应的UML类图

![](https://cdn.nlark.com/yuque/0/2024/png/49784329/1730096518456-e33a2bc8-3d34-495c-89ee-a43b39d5d9a5.png)

其中BattleMgr 中有鱼的管理器 FishEntity(继承自EntityBase) ,这个是纯数据块，逻辑和表现分离

Enity 中属性字段根据功能的不同分别注册在不同的System中，来实现暂停相关逻辑的同步





### 这些改动的好处
1. 实现了逻辑和表现的分析，轨迹由MoveSystem 根据FishEntity中的出生时间戳进行相关位置的运算。

2. 服务端数据刷新同步都是实时刷新数据，后续的System中处理相关逻辑。

3. 方便拓展，如果有Buff系统或者技能系统，可以很容易拓展。

### 拓展逻辑举例：
停止掉某个鱼的移动，可以把对应的冷冻时间戳同步到FishEntity中，MoveSystem.caculateFishPosition中计算鱼的位置，而不用大改框架结构。

同步相关的开火逻辑和停火逻辑，发送对应的时间戳同步到GunEntity中，GunSystem.caculateBullet函数中，进行子弹个数以及位置的逻辑运算，而不用大概框架结构



  




## 3.网络延迟的相关处理
  


![](https://cdn.nlark.com/yuque/0/2024/png/49784329/1730093296017-630b8b0f-eb2b-4793-a569-363adc397477.png)

可以看到由于网络延迟，服务器回包的时间往往比单机的时间要晚一些，如果有网络波动情况，如ClientB 那么此时他看到的画面比ClientA晚了2秒，所以客户端发送的时间戳和接收到消息的客户端时间戳进行比较，如果超过一定的阈值，需要进行微加速，在RoomTime这个类型的处理新增timescale，并将它放大，直至2个时间差小于阈值





客户端本地计算出网络延迟的时间，设定一定阈值实现，Δtime = 网络时间偏差值 ~~本地发送时间戳– 本地收到的时间戳~~

阈值表示理想条件下收发该条协议时间值

<font style="color:red;">（该运算不涉及到客户端</font><font style="color:red;">/</font><font style="color:red;">服务端时间同步）</font>

<font style="color:red;"></font>

<font style="color:red;">每次</font><font style="color:red;">update </font><font style="color:red;">，</font>

判断Δtime 时间大于阈值（比如500ms）

<font style="color:red;">那么进行如下计算</font>

```csharp
var gap = Time.unscaledDeltaTime;
if(deltaTime > 0.5f)
{
    deltaTime -= (timescale - 1) * gap;
    RoomTime.deltaTime = gap * timescale;
}
else
{
    RoomTime.deltaTime = gap
}
```



其中

timescale 可以动态计算

targetTimescale = 1 + (Δtime / 最大阈值) * (最大timescale - 1)

为了避免timescale 突变也应该在平滑过渡

currenTimeScale = lerp(curretTimeScale, targetTimescale,系数)



回调系统接口SytemBase.onTimeScaled，<font style="color:red;">unity相关的系统怎么加速需要自行判断</font>



在这样的情景下，RoomTime.startTime 没有变化，Entity需要同步的生成时间戳也没有变化，理论中的路线等等的逻辑运算也应当没有变化，又刚好将端B的延迟的情况补齐



### 3.1 客户端暂停处理


其中Time.unscaledDeltaTime在客户端暂停时，此时时间值会非常大，为兼顾调试需要

#### 1.在调试模式下：
调试需求是画面不变，所以

```csharp
{
    RoomTime.deltaTime = Time.deltaTime 
}
```

<font style="color:#DF2A3F;">调试画面可能会不同步</font>

#### 2.在RunTime模式下：
不处理



## 4.具体可以实施的方案（讨论）
以下都是Lua代码

### 新增RoomTime类型单例
主要负责房间时间的循环，提供房间的各种时间参数

### 新增SystemBase 类型
主要是各种管理器的基类，主要负责单个系统内部逻辑的暂停和开启，其他System则继承该基类

一些系统都继承自SystemBase

:::info
*新增FishMoveSystem 主要负责大鱼的移动，需要修改类型Ef_AutoMove

*新增BulletMoveSystem主要负责子弹的移动，同样需要修改类型Ef_AutoMove ，该系统目前同步的数据是开关火的状态，并不是基于RoomTime的时间，如果后续需要同步子弹相关逻辑，<font style="color:red;">保留修改的能力。</font>

*新增GunSystem处理炮台同步的相关逻辑，目前炮台的同步只是同步最终的方向，没有相关的时间戳，无法平滑，如需修改，也<font style="color:red;">保留相关的能力</font>。

*新增FishGenSystem 继承SystemBase 主要负责鱼的生成，如果小鱼需要同步，<font style="color:red;">客户都相关的生成算法需要一致</font>，小鱼生成器的时间也需要同步，当然也可以<font style="color:#00b050;">复用大鱼的逻辑。</font>

:::



### 新增 EntityBase 类型
主要内部参数为time, 基于RoomTime的时间偏移，可以支持单个单位的暂停逻辑，需要和服务器行为一致

:::info
*FishEntity 继承该类，主要负责存鱼的数据，该数据部分需要服务端同步，比如是否死亡，资源id，等等，需要将现有的FishBase移动到该类型中

*BulletEntity 子弹数据

*GunEntity 炮台数据，方向，位置等

*FishGenEntity 小鱼生成器相关的数据

:::



### 修改BattleMgr 
:::info
*核心函数update中驱动各级的System去update

*持有所有的Enity，负责服务器的消息收发，同步核心数据到EntityBase中

*负责各个子系统的初始化，鱼群的初始化

*了解到这个脚本非客户脚本，需要一定的解耦

:::

### 4.1 代码公用
![](https://cdn.nlark.com/yuque/0/2024/png/49784329/1730181413387-d0298eb4-2bb7-42fc-ac08-58da908c4fa4.png)

公用代码部分在FishingRoom ,FishingRoom 中通过事件管理器来解耦客户端逻辑

在上述架构设计中，FishRoom用来处理服务端和客户端的公用逻辑，所以理应游戏中的逻辑相关的处理，也应该在此处，FishEntity中都是纯数据块



关于System的处理，应该区分不同的模块，如果此模块只涉及到客户端处理，那么在服务端跑脚本的时候，在BattleMgr内部的容器中，应该不予注册

```lua
if MODULE_GAMECLIENT then //注册客户端的System
  reg(ShowSystem);
  reg(ActorSystem);
end
```

如果是客户端UI相关的功能，通过事件来进一步解耦

### 4.2 各个的系统的详细修改（讨论）
资源加载的流程

![](https://cdn.nlark.com/yuque/0/2024/png/49784329/1730188084450-cdde2cb5-7a94-40cd-9672-184d4320b73a.png)

可以将BattleRes 修改为LoadSystem,提供接口，仅供客户端使用

void LoadSystem:LoadFish(FishEntity fish)

其他示例

void LoadSystem:LoadGroupFish(FishGroupEntity fish);

void LoadSystem:LoadGun(GunEntity fish)  

如果各个Entity中字段是同一个字段，可以统一处理

### 4.3 单机模拟 （讨论）
初步想法修改RPC的协议，直接调用相关的代码

如TestSceneVirtualServer.lua

```lua
-- 接管部分渔场内使用的服务器协议
function TestSceneVirtualServer.AddListen()
	Rpc.CallServerScript = function (self, data)
		if data[2] == "REQUEST_USE_ITEM" then
			TestSceneVirtualServer.OnPlayerUseFishRoomItem(data[3])
		elseif data[2] == "REQUEST_SET_RATIO" then
			TestSceneVirtualServer.OnResponseSetRatio(data[3])
		elseif data[2] == "REQUEST_HIT_FISH" then
			TestSceneVirtualServer.OnResponseHitFish(data[3])
		-- elseif data[2] == "REQUEST_SET_USE_FISH_GUN" then
		-- 	TestSceneVirtualServer.OnResponseSetUseFishGun(data[3])
		elseif data[2] == "REQUEST_DO_FISH_SKILL" then
			TestSceneVirtualServer.OnResponseDoFishSkill(data[3])
		end
	end
end
```



有问题的地方，这些方法都是客户端自己实现，相当于实现了2次，如何规范写代码？

```lua
-- 计算捕获
function TestSceneVirtualServer.OnResponseHitFish(fish_list)
	for key, value in pairs(fish_list) do
		for i, v in ipairs(value) do
			local fish_config = ConfigMgr:GetConfigById(CfgEnum.Fish, v.id)
			local fish_type_config = ConfigMgr:GetConfigById(CfgEnum.FishType, fish_config.FishModelID)
            -- 随机鱼
            local random_list = {}
            for index, weight in ipairs(fish_type_config.weight) do
                table.insert(random_list, {["random_index"] = index, ["weight"] = weight})
            end
            local random_index = Lib:RandomByWeight(random_list);
			if must_hit or FishingRoom:IsFishDie(BattleMgr.cur_player_index, fish_type_config.Score[1], fish_type_config.probability) then
				local hit_para = {
					id = v.id,
					score = fish_type_config.Score[random_index],
					random_index = random_index,
					index = v.index,
				}
				local hit_list = {}
				table.insert(hit_list, hit_para)
				EventManager.OnGlobalEvent("OnResponseHitFish", hit_list, me.Id, fish_list)
			end
		end
	end
end
```

对比服务的实现

```lua
--
-- breif 击中鱼群
--
function FishingRoom:OnRequestHitFish(fish_list)
    -- 参数
    if type(fish_list) ~= "table" then
        Debug.Log(string.format("[房间]玩家请求击中鱼群, 参数错误"));
        return;
    end
    -- 检查
    if not self:CheckHitFish(me, fish_list) then
        Debug.Log(string.format("[房间]玩家{%d}击中鱼群失败,检查未通过", me.Id));
        return;
    end

    -- 玩家房间id
    local room_id = self:GetPlayerRoomId(me);
    local extra_ratio = 1;
    -- 是否处于倍率道具使用时间内
    local item_useable = Item:GetItemUseConfig(FishingRoom.FISH_ROOM_ITEM_ID_DOUBLE_RATIO);
    if item_useable then
        local last_use_time = me:GetVar(Player.PLAYER_VAR_GROUP_FISH_ROOM_ITEM_RECORD, FishingRoom.FISH_ROOM_ITEM_TYPE_DOUBLE_RATIO);
        if last_use_time ~= 0 and (last_use_time + item_useable.param3) > GetCurTime() then
            extra_ratio = 2;
        end
    end
    -- 扣钱
    local need_gold = #fish_list * me:GetValue(Player.PLAYER_VALUE_RATIO) * extra_ratio;
    assert(me:SubValue(Player.PLAYER_VALUE_GOLD, need_gold, Player.PLAYER_VALUE_CHANGE_FISHROOM));
    -- 任务更新
    EventManager.OnGlobalEvent("OnPlayerDispatchTaskBehavior", me, Task.TASK_BEHAVIOR_HIT_NUM, #fish_list);
    -- 扣钱记录
    local gold_sub_num = me:GetVar(Player.PLAYER_VAR_GROUP_FISH_ROOM_ONCE_ITEM_RECORD, self.FISH_ROOM_ONCE_ITEM_RECORD_GOLD_SUB);
    -- 玩家设置扣钱记录
    me:SetVar(Player.PLAYER_VAR_GROUP_FISH_ROOM_ONCE_ITEM_RECORD, self.FISH_ROOM_ONCE_ITEM_RECORD_GOLD_SUB, gold_sub_num + need_gold);
    -- 玩家buff当前提供额外倍率
    local cur_coe_rate = Buff:GetPlayerCurBuffCoeRate(me);
    local hit_list, score, buff_score = self:PlayerHitFish(room_id, me.Id, fish_list, extra_ratio, cur_coe_rate);

    if score > 0 then
        -- 实际获得金币 = 鱼分 * 当前倍率
        local add_glod = score * me:GetValue(Player.PLAYER_VALUE_RATIO);
        -- 加金币
        me:AddValue(Player.PLAYER_VALUE_GOLD, add_glod, Player.PLAYER_VALUE_CHANGE_FISHROOM);
        -- 加金币记录
        local gold_add_num = me:GetVar(Player.PLAYER_VAR_GROUP_FISH_ROOM_ONCE_ITEM_RECORD, self.FISH_ROOM_ONCE_ITEM_RECORD_GOLD_ADD);
        -- 玩家设置道具使用时间
        me:SetVar(Player.PLAYER_VAR_GROUP_FISH_ROOM_ONCE_ITEM_RECORD, self.FISH_ROOM_ONCE_ITEM_RECORD_GOLD_ADD, gold_add_num + add_glod);
    end
    -- 扣除玩家buff提供金币
    if buff_score > 0 then
        Buff:OnSubPlayerBuffCount(me, buff_score * me:GetValue(Player.PLAYER_VALUE_RATIO));
    end
    --
    for k,v in pairs(hit_list or {}) do
        local ratio = me:GetValue(Player.PLAYER_VALUE_RATIO);
        local fish_type = FishingRoom:GetFishType(v.id);
        -- 鱼分
        if (v.score * ratio * extra_ratio) >= FishingRoom.SPEAKER_SCORE_MIN then
            local fish_name = FishingRoom:GetFishName(v.id);
            Chat:SendSpeaker(Chat.SPEAKER_FISH_GOLD, me.Id, me.NickName, ratio, fish_name, (v.score * ratio * extra_ratio) * FishingRoom.SPEAKER_SCORE_CLIENT_RATE);
        else
            -- 鱼类型
            if fish_type >= FishingRoom.FISH_TYPE_BOSS then
                local fish_name = FishingRoom:GetFishName(v.id);
                Chat:SendSpeaker(Chat.SPEAKER_FISH_TYPE, me.Id, me.NickName, fish_name);
            end
        end
        -- 跑马灯判定
        local settle_type = FishingRoom:GetFishSettleType(v.id);
        local fish_score_list = self:GetFishScore(v.id);
        if v.random_index == #fish_score_list and settle_type == FishingRoom.FISH_ROOM_SETTLE_TYPE then
            Chat:SendSpeaker(Chat.SPEAKER_MAX_FISH_RET, me.Id, me.NickName, v.id, v.score * me:GetValue(Player.PLAYER_VALUE_RATIO));
        end
        -- 任务更新
        -- 鱼群类型
        local fish_model_id = self:GetFishModelId(v.id);
        EventManager.OnGlobalEvent("OnPlayerDispatchTaskBehavior", me, Task.TASK_BEHAVIOR_HIT_FISH_TYPE, 1, fish_type);
        EventManager.OnGlobalEvent("OnPlayerDispatchTaskBehavior", me, Task.TASK_BEHAVIOR_HIT_FISH_SUB_TYPE, 1, fish_model_id);
        EventManager.OnGlobalEvent("OnPlayerDispatchTaskBehavior", me, Task.TASK_BEHAVIOR_HIT_FISH_GUN_RATIO, 1, ratio, fish_model_id);
        EventManager.OnGlobalEvent("OnPlayerDispatchTaskBehavior", me, Task.TASK_BEHAVIOR_HIT_FISH_GOLD, v.score * ratio, fish_model_id);
    end

    local room = self:FindRoom(room_id);
    -- 更新玩家当前金币
    if room.player_list[me.Id] then
        room.player_list[me.Id].gold = me:GetValue(Player.PLAYER_VALUE_GOLD);
    end
    self:Broadcast(room, "OnResponseHitFish", hit_list, me.Id, fish_list);
    -- Rpc:CallClientScript(me, {"FishingRoom", "OnResponseHitFish", hit_list});

    Debug.Log(string.format("[房间]玩家{%d}命中子弹数量{%d}", me.Id, #fish_list));
end
```

服务端的逻辑部分会非常多，除了鱼本身的的命中逻辑还有其他模块比如Task，或者跑马灯，或者广播等等，但是这些属于非战斗模块的东西，

~~如果有对应战场之外的逻辑建议有个宏来控代码~~

~~<font style="color:#DF2A3F;">以下是伪代码</font>~~

~~<font style="color:#DF2A3F;">比如FishRoom:OnRequestHitFish(fish_list)</font>~~

:::info
FishSystem:OnHit(fish_list) //方法里面调用FishEntity:OnHitRate()方法来实现逻辑公用



~~if not BATTLE_CONDITION then //非战斗代码 客户端单机捕鱼战斗，没有这些数据块，调用很可能报错~~

~~self:Broadcast(xxx)~~

~~Task:onFinish(xxx)~~

~~chat:onxxxx()~~

~~end~~

:::



<font style="color:#DF2A3F;">1.抽取公用逻辑</font>

## 5.后期优化
将BattlerMgr 的update帧率下降，降低客户端的函数开销，比如降频至1s/20帧 0.05s

将表现单独的拆分出来，用lerp/slerp来做相关的插值计算



