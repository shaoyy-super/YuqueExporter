## 1.Unity
我们在日常开发时有一个单独的开发场景

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913063431-5607c7ad-49b7-4615-9fe0-2c848dd434cd.png)

点击UI制作页签就可以进入我们的开发场景了

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913072530-6560df4c-cbdb-4ac3-af9c-aa8e0cbd901d.png)

可以看见在新建的场景中已经内置了光源、相机等等，但是咱们重点关注的是效果图和Root

效果图是UI同学给过来的美术效果，咱们得对着UI图进行UI的拼接。效果图的话正常美术同学有一个自己的git项目，用来上传UI的效果资源等等，以Box项目为例

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913082026-02714231-084e-4aaf-ac88-43403af38abb.png)

一般的目录是项目-> UI -> 效果图 -> 对应系统，就可以看见在这个登录目录下就看见了这个UI的效果图

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913093681-869d4a3c-aa98-4dab-935b-24652b2a98cb.png)

然后我们将这个效果图导入到工程中，再在效果图上找到咱们刚刚添加的图片(PS:记得加进来的图片千万不要提交上去哈！)

然后我们就能在场景下找到这个效果图啦

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913106313-750f438f-9923-4f26-b178-89455c372ab5.png)

介绍完效果图，接下来就到Root了，Root是咱们UI界面的根节点，Root下的UI_Xxx_Panel

就是咱们的UI界面了，比如咱们现在的是登录界面，那这个UI咱们就命名为UI_Login_Panel

接下来就是分析这个界面，这时一般美术同学会提供示意图给我们

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913117349-abf8b2ce-56f2-4564-a632-96bd4cdb86b2.png)

一般的话和效果图的目录是在一起的，这里现在没有，就之后在补充吧。

根据示意图就可以更好的去分解这个界面，继续用登录界面做分析。

首先是背景，截屏模糊，其次是右上角的区服列表，按钮和下拉菜单，然后是登录面板，面板的背景，标题，账号和密码的输入框，以及登录按钮。

截屏模糊，这个可以在代码中设置，这个我们一会再说

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913151482-da201c48-2cb1-4719-8cf1-a3c51e155f13.png)

可以看见我们在Panel下创建了一个Btn和一个Text。

现在对象有了，那我们如何控制这些组件里的属性呢？

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913173686-fb170cda-6b75-4f38-890d-957694f92824.png)

可以看见在Panel下挂载了两个组件Component 4 Lua 以及Lua Behaviour组件

GameObjcetList下存放的是咱们需要代码控制的GameObject对象

ComponentList下存放的是需要代码控制的GameObjcet下挂载的组件

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913188015-75465d69-6469-45c0-8184-dcd0012d5339.png)

我在这个脚本下挂载了这些组件

这时咱们就去看看业务逻辑

## 2.业务相关
![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913213425-d3aa6a90-102e-41b6-b191-67b5a7c86dc0.png)

咱们的开发的新系统都得在CSys目录下新建一个目录用来存放自己的代码

如上所示，我创建了一个Login的文件夹，我们的UI，Page以及Scene都得在这个目录下(我这里没这么多东西，我们看看别的已经有的功能)

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913224633-55ee0af5-5ab6-486b-b3c3-6e1996b27bd0.png)

咱们用战斗系统做举例

首先可以看见和战斗有关的Page等lua文件都是直接存放Battle模块下(<font style="color:rgb(229,76,94);">这点得注意！！！</font>)

而GL、Misc等文件夹下存放的就是系统的公共方法等代码的，我们在日常开发的时候也可以参考这种做法，可以减少代码量，提高可观赏性。



接下来，咱们来看看各个文件是做什么的

首先是Scene文件：在咱们的场景加载时会走到这个脚本，在这里可以对场景的资源进行预加载，也可以在场景中寻找场景中的节点，再对该场景里的物体进行相应的操作。多个Page可能会使用同一个场景，Scene也可以对Scene切换做一些处理，从而减少耦合的代码。Scene的Destroy则是真正退出情景的时候，此时我们才会考虑一些场景资源的卸载。



然后就是Page文件：咱们在场景加载完后会打开咱们UI对应的Page，在Page里也可以处理一些UI资源的预加载，Page打开时使用哪个UI，Page关闭时，UI资源的卸载等等。

Panel文件：Panel文件就是对咱们UI资源的管理的文件。Page文件下可能会有多个UI，Page文件也得管理这些UI之间的关系。其次Page最重要的就是Goto和GoBack功能，Goto是从这个Page跳转到其他Page，而GoBack则是从其他Page跳转回来



![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913252833-2d664bfe-0ae9-486a-b45f-973896b8bc5f.png)

这里我新建了一个UI_Login_Panel的lua文件，首先我们能看见组件路径，这个组件路径的名字最好可以见名知意，但是枚举里面的value值必须和我们Component 4 Lua上的下标是一样的。

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913264207-cf4e8a2d-f827-434f-80f5-5ea74fc26142.png)

这是由于在Component4Lua脚本中所有的对象都是通过下标来进行索引的

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913276333-a1a3f153-887b-4228-aaf5-3ff361121a57.png)

由图我们不难看出其中的逻辑关系

在Panel文件中所有的与页面属性相关的代码都得在这里完成，然后暴露一个接口给我们的Ctrl文件使用

可以看到我在Panel的文件中定义了三个方法，一个是通过对象名来获取GameObject对象，一个是设置按钮上的文本，还有一个是设置按钮的状态，接下来我们就在Ctrl里看看他们的用法。



Ctrl文件：Ctrl文件是用来处理我们开发过程中的业务逻辑，以登录为例，在登陆时首先得获取玩家的登录记录，查询本地的缓存数据。其次在点击登录按钮后，发消息给服务器，以及接收到服务器的成功的消息后界面的变化，这些业务逻辑都是在这里实现的。

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913310216-f246d274-c0ea-4edc-b3c4-1417624f8e69.png)

如上图在UI_Login_Ctrl文件中我们在OnCreate时就给我们的BtnServer按钮绑定了点击事件_OnClickServer，在OnShowUI时又使用了我们Panel中所定义的方法，修改了Server的Text文本内容，以及修改了BtnServer按钮的状态。

而我们在业务开发时通常会有一些重复的功能，比如在开发一些玩法功能时，你需要知道世界地图的主线打到那一关了？这时就可以去对应功能的GL里去找相应的代码，或者去问问对应功能的开发同学，有没有这种接口，没有的话，可以请求别人提供等等，所以我们在开发自己的模块时遇到一些比较通用的方法或者功能时就可以新建一个目录，在其中放一些通用功能的代码。例如战斗模块的结构

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913323369-7a0e45b6-3532-47de-b80f-4cd55a250fa7.png)

Scene文件和Page文件得看对应的功能需求，如果我们开发的功能只是其他功能的延申，那一般就不会去牵扯到Scene和Page，但是如果是基于新场景的开发，一般都会有场景的需求，接下类咱们就来看看Scene以及Page的配置文件



## 3.SceneDefine
![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913353928-6de2060f-2849-404d-94e1-54df3ec2705c.png)

SceneEnum 场景枚举，该枚举的Key即为定义的场景名，value值则为’SceneInfo’表中的Id，Id后对应的即为场景中所对应的资源名称

ScenarioEnum 情景枚举

来说明一下它们俩之间的关系吧

一个情景下可能会有多个场景，在进入一个情景的时候，我们可以对该情景下的场景做一些设置，比如预加载等。如果选择预加载的话，我们在进入情景的时候，就会将这些场景资源全部加载出来。不选择预加载的话就不在进入情景时就加载这个场景，但是在我们进行场景切换时还是需要等待场景资源加载。因此在情景中一些常用的场景可以进行预加载处理，但是太多的话，也会导致情景切换的时候会Loading很久，这个就需要看我们的需求来酌情考虑了。

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913370902-de3a17ac-d9d8-4333-b59b-07c326c71b0a.png)

ScenarioConfig 情景配置

可以看出第一个中括号内对应的是我们的情景枚举，之后才是我们的场景枚举

如上图可以看到场景后的参数分别对应着(是否需要预加载，是否需要常驻，第一次进入场景是是否需要Loading，再次进入是是否需要走Loading，附加场景Id)



## 4.PageDefine
在PageDefine中咱们需要注意的主要有两点PageEnum和CustomRegister

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913404618-29c68305-8090-497e-b20a-a0ccd58d6613.png)

在PageEnum中的枚举需和自己的PageCtrl的名字有所关联

如Page_Battle_Ctrl => PageEnum.Battle

当你的Page没有独立的PageCtrl时，就需要使用Adapter进行注册

如上图，需要UI的名字，Page对应的枚举，以及一些基础的自定义参数

最后就是我们UI的配置了



## 5.SysDefine文件
![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913445176-dc4c69aa-edd2-4b9b-b418-fff336000d20.png)

UIEnum为Ui枚举，我们所创建的所有Panel都得在这里列出来，之后就可以很方便的找到对应的界面了。

LayerName为UI层级，层级大小Top>Msg>Default(最常用的)>Battle,在我们日常开发中Default层级即为正常UI的层级，Msg适合弹窗类UI使用，Top则适合跑马灯等层级最高的UI使用。

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913456566-857156db-3c08-4abf-bbc0-d28553f78ca9.png)

在Modules下面跟着的就是我们的功能模块名称

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913468507-ac1143fc-803d-4707-93dc-3f7428795063.png)

以战斗模块为案例

Page：为该模块对应的Page枚举(没有可以不填)

Scene： 为该模块对应的Scene枚举(没有可以不填)

UI： 中括号内对应的是UI对应的枚举

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712913477874-70804907-641f-4cd1-baff-e6676ac93cd6.png)



|    名称 | 功能 |
| --- | --- |
| RefUI | 暂不考虑(已弃用，先填nil等待后续优化) |
| LayerName | 层级类型(Top>Msg>Defalut>Battle，层级越高两个UI叠在一起时曾层级高的就会显示在上面) |
| LayerOrder | 层级排序(如有两个Top层级的UI，一个Order是0，一个Order是1，那么这个Order为1的就比Order为0的高一个层级) |
| Preload | 是否需要预加载 |
| Resident | 是否需要常驻 |
| StackType | 堆叠类型(现在有两种类型 1 和 2。类型1为自行管理，如在界面A中打开了一个界面B，这时我们不仅得负责将界面B关闭，还需要将界面A给打开。类型2是Page管理，这时我们在打开一个UI时Page就会有一个堆栈记录打开过的UI，比如我打开了A界面又打开了B界面接着又打开了C界面，这时Page就会记录一个A B C 的堆栈，当我们关闭界面C时，由于堆栈的特性，Page就会打开B界面，就不需要我们去进行管理了) |
| IsFull | 是否全屏 |
| IsBlur | 是否需要模糊 |


