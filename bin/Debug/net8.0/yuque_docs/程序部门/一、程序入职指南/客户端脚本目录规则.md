## 1. **目录**
### 1. 新开发的模块得新建文件夹放在CSys目录下面，如图：
![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712920206703-4b73b08c-3acb-441e-a2ba-4d6d85a03a76.png)

### 2. 模块对应的UI，Page，Scene文件需直接放在模块目录下，模块的功能方法可以新建目录进行存放，如图：
![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712920229282-1f1a3eac-c78d-4bdc-a5d3-19f7b5f19e38.png)

## 2.Unity
![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712920254690-e8cbcc93-58ee-497f-826b-a93ef62822a4.png)

### 1.我们制作UI有自己的场景进行制作，需在该场景下进行UI制作.
### 2. UI命名：UI命名得见名知意，如登录 -> UI_Login_Panel.
### 3. 拼UI时可以将效果图贴到项目中，以便我们确认UI元素的位置.
### 4.在UI_Xxx_Panel下需要挂载两个脚本Component 4 Lua 和 Lua Behaviour(已默认挂载)。
### 5. Component 4 Lua下的GameObjectList和ComponentList下需要挂载我们Lua代码需要控制状态及属性的GameObject和Component。


## 3.**UI**
### 1. Panel
1. Panel需要有组件路径，组件路径名最好可以见名知意，枚举的Value值必须与Component 4 Lua中List的下标一致(因为该脚本是通过下标查找元素的)

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712920434301-9292873e-dc36-4919-b4f6-0d097ac8be17.png)

2.所有有关UI组件属性的修改都必须在Panel中实现，并且暴露接口供Ctrl使用。

### 2. Ctrl
Ctrl中只处理模块相关的业务逻辑，资源尽量管理交给Page和Scene处理，UI上的显示内容都交给Panel处理，Ctrl只负责调用即可。

### 3.SysDefine
1. 所有的UI都得添加到UIEnum枚举中。如下图：

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712920553441-607bf4f5-040f-4c24-ab76-6e8e3840a5a6.png)

2. CSys下的Modules需要添加我们的模块以及对应的UI，Page，Secne如下图：

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712920567951-605b8f03-e793-40e3-b73e-6c66f53a7c5a.png)

其中Page和Scene得看自己的UI有没有对应的需求

3. Modules块中UI内部各个参数的含义



| 名称 | 功能 |
| --- | --- |
| RefUI | 暂不考虑(已弃用，先填nil等待后续优化) |
| LayerName | 层级类型(Top>Msg>Defalut>Battle，层级越高两个UI叠在一起时曾层级高的就会显示在上面) |
| LayerOrder | 层级排序(如有两个Top层级的UI，一个Order是0，一个Order是1，那么这个Order为1的就比Order为0的高一个层级) |
| Preload | 是否需要预加载 |
| Resident | 是否需要常驻 |
| StackType | 堆叠类型(现在有两种类型 1 和 2。类型1为自行管理，如在界面A中打开了一个界面B，这时我们不仅得负责将界面B关闭，还需要将界面A给打开。类型2是Page管理，这时我们在打开一个UI时Page就会有一个堆栈记录打开过的UI，比如我打开了A界面又打开了B界面接着又打开了C界面，这时Page就会记录一个A B C 的堆栈，当我们关闭界面C时，由于堆栈的特性，Page就会打开B界面，就不需要我们去进行管理了) |
| IsFull | 是否全屏 |
| IsBlur | 是否需要模糊 |




## 4.Page
![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712920742086-6efcd370-c1fb-43dc-aeb6-3f2bb2e46bf3.png)

1. 在新建一个Page后须在PageDefine中添加相应的枚举值。

2. PageEnum枚举的Key需和PageCtrl具有关联性，如Page_Login_Ctrl -> PageEnum.Login。

3. 不具备独立PageCtrl的Page需要在Adapter中进行注册，具体格式可以参考上图.



## 5.Scene
![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712920783316-b2b9e620-3f22-4095-83ae-e9fd7a86e4ad.png)

在新建一个Scene后须在SceneDefine中添加对应的配置

SceneEnum 场景枚举，该枚举的Key即为定义的场景名，value值则为’SceneInfo’表中的Id，Id后对应的即为场景中所对应的资源名称

ScenarioEnum 情景枚举，该枚举下列出的是现在项目中所有的情景。

![](https://cdn.nlark.com/yuque/0/2024/png/43297665/1712920794731-02c9c5b2-26bd-4384-ba00-357c50f576dd.png)

ScenarioConfig 情景配置

可以看出第一个中括号内对应的是我们的情景枚举，之后才是我们的场景枚举

如上图可以看到场景后的参数分别对应着(是否需要预加载，是否需要常驻，第一次进入场景是是否需要Loading，再次进入是是否需要走Loading，附加场景Id)

