## 一、客户端性能介绍
1.客户端性能这里对<font style="color:rgb(243, 50, 50);">2D和3D类</font>游戏进行展开进行，讲述的有<font style="color:rgb(243, 50, 50);">内存、CPU、GPU、帧率</font>这几个模块内容。其中不管是2D还是3D类游戏，都一定会包含有<font style="color:rgb(243, 50, 50);">图片、字体、音频</font>这些资源。

<font style="color:#000000;">2.</font><font style="color:rgb(243, 50, 50);">2D类游戏主要的资源是图片，所以对于渲染这块的内容核心在于CPU的draw call方面。</font>

3.<font style="color:rgb(243, 50, 50);">3D类游戏包含的资源很多：模型、物理组件、光影效果、网格、shader、材质纹理等</font>，所以<font style="color:rgb(243, 50, 50);">3D类游戏在渲染这块的内容核心包括CPU的draw call以及GPU的渲染计算方面</font>。下面分别对影响内存、CPU、GPU性能方面进行讲解。



## 二、影响内存的因素
1.对于一款游戏，基本的可以分为<font style="color:rgb(243, 50, 50);">脚本和资源</font>两部分，而<font style="color:rgb(243, 50, 50);">脚本通常会包括代码和导表数据</font>。

（1）对于代码中，<font style="color:rgb(243, 50, 50);">没有及时回收无用的变量，则会占用了内存空间，慢慢累积后</font>也变成了<font style="color:rgb(243, 50, 50);">内存泄漏</font>。

（2）导表数据也是一个需要关注的点，游戏里面有某些表格往往会比较大，有的甚至达到几M的数据，而在一个场景中，可能要加载多个表格的数据，需要将这些需要用到的表格都加载进入到内存当中，但是实际上，当前场景所有到的数据往往仅是数据表格的一小部分数据而已，这就导致了有大量的表格数据在内存中是无用的，但是又必须要加载进去。所以，表格数据的优化也是一个比较重要的内容之一。



2.常规的表格优化策略有：

+ <font style="color:rgb(243, 50, 50);">通过功能数据放在独立的表格</font>
+ <font style="color:rgb(243, 50, 50);">去除表格中未被使用的冗余字段</font>
+ <font style="color:rgb(243, 50, 50);">对数据量大的表格进行分块处理，使用中间文件做索引，做到分块导表，按需加载·</font>



3.通用资源：而对于资源内容，通用的资源有**<font style="color:rgb(243, 50, 50);">字体、音频、UI、纹理图片</font>**，这些通用资源里面其实已经包含了2D资源，因为2D资源也就是以上的这些内容。而3D的则还有**<font style="color:rgb(243, 50, 50);">网格、材质、着色器</font>**这些内容。



4.字体：一款游戏中使用到的字体往往有多种，而一个字体小的有几兆，大的甚至十几兆，而游戏中加载字体都是全部加载进去且大部分是常驻内存的，并且游戏在开发期时，可能使用了多款字体，但是实际上游戏中使用的没有么多，导致字体在内存中占用了许多的内存。所以针对这点，我这里也拿出来提及一下，<font style="color:rgb(243, 50, 50);">因为字体的加载大小几乎等同于字体实际的大小，可以说是冗余的字体和多种字体既占包体量也占内存</font>。



5.音频：游戏音频也是会对内存造成一定的占用的，这点也同样需要在性能测试过程需要考虑的。

（1）游戏里面常用的音频有ogg格式的，mp3格式的，wav格式的以及wwise音频引擎的使用bnk格式作为音频资源。对于游戏音频，一种常规的优化策略是：

+ <font style="color:rgb(243, 50, 50);">对于长时间的音乐，建议采用压缩格式的mp3</font>
+ <font style="color:rgb(243, 50, 50);">对于短时间的音效，建议采用非压缩格式的wav</font>

（2）对于unity里面的音效设置，刚开始的音源文件可能是1.4Mb，如果采用的格式是加载时解压缩，那么最后的音源在内存中的大小将=高达10.2Mb。

（3）所以音源的加载策略也是一个很重要的影响因素。一般的加载方式<font style="color:rgb(243, 50, 50);">有加载时解压缩、压缩内存、流式处理</font>。  
（4）这几种方式各有优缺点，无非就是在<font style="color:rgb(243, 50, 50);">速度与内存空间两个方面的取舍程度</font>，需要项目里面根据实际的需求选择合适自己项目的方式，具体问题具体分析。

![](https://cdn.nlark.com/yuque/0/2024/png/43256946/1713148735328-2a442c7f-64a7-4015-8801-272d47856ed5.png)

6.UI：游戏UI界面往往容易造成的性能问题是<font style="color:rgb(243, 50, 50);">卡顿、界面打开慢等，导致UI的过度绘制</font>。

（1）在游戏中，UI的销毁处理一般有三种情况，一种是<font style="color:rgb(243, 50, 50);">关闭UI后立即销毁，不做任何的缓存</font>；

（2）第二种是<font style="color:rgb(243, 50, 50);">第一次打开UI后，对UI先进行缓存处理，关闭UI后，不销毁UI，下次打开速度快，等到切换场景时才销毁</font>；

（3）第三种是<font style="color:rgb(243, 50, 50);">关闭UI后，不销毁UI，切换场景时也不销毁，直到内存达到预警值时再进行销毁</font>；

（4）对于我们测试来说，需要了解UI在内存的处理方式后，还需要<font style="color:rgb(243, 50, 50);">关注该种模式下是否存在掉帧、卡顿的情况，是否出现内存泄漏的情况</font>。

（5）如果有，那么我们需要定位出来是那些<font style="color:rgb(243, 50, 50);">UI导致的掉帧、卡顿或者内存泄漏</font>。常规的做法有：

+ <font style="color:rgb(243, 50, 50);">程序在客户端打印每个场景界面的UI列表log，列出UI的名称、尺寸、大小，测试人员可以收集前后的UI数据定位出问题所在</font>
+ <font style="color:rgb(243, 50, 50);">使用renderdoc查看某界面的资源加载情况，确认哪个资源，那一帧导致的掉帧、卡顿问题，renderdoc的使用方法请参考：renderdoc的使用</font>
+ <font style="color:rgb(243, 50, 50);">使用prefdog等工具查看内存是否存在泄漏情况，并确认是否与UI重复打开关闭导致的</font>



7.纹理图片：<font style="color:rgb(243, 50, 50);">纹理对于内存的消耗是巨大的</font>，一个2048*2048的纹理，采用32位颜色深度编码的话，将消耗16M的内存，一个1024*1024的纹理也需要消耗4M的内存<font style="color:rgb(243, 50, 50);">（大体计算方式：（大小）*（编码位数/8)，即1024*1024*（32/8)byte =1024*4kb = 4Mb)。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/43256946/1713149328312-4b006842-5a85-428c-b007-e4f3602e4501.png)

<font style="color:rgb(255, 0, 0);">以上场景的纹理贴图中2048*2048规格的的图片占用内容会比较大，这些纹理贴图需要美术优化。</font>

需确认纹理在512*512、1024*1024、2048*2048几种大小以及在dds、tga两种格式下的内存占用情况，目标如下：

![](https://cdn.nlark.com/yuque/0/2024/png/43256946/1713149508897-8a8743b8-cc75-4859-a32f-2f699793e71d.png)

纹理的处理可以经过压缩，不过压缩后，效果可能不是很理想。

<font style="color:rgb(243, 50, 50);">方案一：在原图的基础上，将纹理的长宽分辨率比例放大一倍，然后在保持原有的压缩格式，这样压缩出来的结果还是要比原图要小一些</font>。

<font style="color:rgb(243, 50, 50);">方案二：进行高中低配分级处理，先设置好分级，针对中低档设备则进行纹理压缩，针对高端档设备，可以保持不压缩纹理，为了更好的显示效果</font>。



## 三、3D类游戏资源
1.网格：<font style="color:rgb(243, 50, 50);">需要能够确定出场景模型的网格占用情况，对于unity3D类的模型中，有些模型没有勾选【Rig】下的Optimize GameObject（优化游戏对象）选项，这个选项可以把SceneManager中用于Skinning的节点都去掉，从而节省场景节点树更新以及查询的CPU消耗</font>。

与此同时，<font style="color:rgb(243, 50, 50);">网格文件Mesh里面会包含有大量的color数据，normal数据，tangent数据。这些数据也会对内存占用比较大</font>。



2.材质贴图：3D的材质贴图主要是<font style="color:rgb(243, 50, 50);">纹理贴图</font>，纹理贴图中我们需要关注的有:<font style="color:rgb(243, 50, 50);">纹理格式，纹理的尺寸、mipmap功能，勾选了read&write功能等</font>。这些都会影响到游戏内存的。



3.纹理格式：纹理格式，需要设备硬件支持，不过目前为止基本大部分设备都支持了各种格式的纹理了，不过可能还会遇到如下的两个问题：

![](https://cdn.nlark.com/yuque/0/2024/png/43256946/1713149939601-75bea108-e11a-4a45-ae3c-e3e3badb6458.png)

4.纹理尺寸问题：纹理的大小的计算和上面贴图所示的估算公式一致。

（1）纹理的<font style="color:rgb(243, 50, 50);">mipmap和read&write功能</font>可以在unity中的纹理属性中看到是否有勾选。

（2）一般情况下<font style="color:rgb(243, 50, 50);">场景、人物、特效模型的mipmap建议勾选</font>，会提高渲染效率，虽然勾选后，内存会增加1.33倍，但是渲染效率大大提高，还是值得的，但是UI的纹理建议不要勾选了，UI本身就渲染在屏幕上，渲染提高不大，反而会增加了额外的内存；

（3）然后read&write选项建议不要勾选。

![](https://cdn.nlark.com/yuque/0/2024/png/43256946/1713150279900-6c086154-f4d8-40e3-a414-12242ff9db0a.png)



5.着色器（shader）：<font style="color:rgb(243, 50, 50);">shader作为能增强炫丽的渲染效果的脚本，很多时候程序、TA为了增强效果，加了好多shader，这个可能会对内存有较大的开销</font>。如下图是我自制的一个很小的单场景demo下shader所占用的内存空间就多大5.1Mb了。那在一款成型的3D类游戏中，可能会有更多的shader内存了。

![](https://cdn.nlark.com/yuque/0/2024/png/43256946/1713150625063-e198d0eb-042b-4306-94f2-0df89fae9d65.png)



## 四、影响CPU性能的因素
1.游戏中影响CPU性能除了<font style="color:rgb(243, 50, 50);">本身游戏逻辑代码处理</font>之外，CPU<font style="color:rgb(243, 50, 50);">对于渲染指令的处理</font>也是影响其性能的主要原因之一。

（1）主要就是这两块影响的，对于逻辑代码这块，主要就是<font style="color:rgb(243, 50, 50);">编程规范和算法设计的不合理导致CPU出现性能压力</font>。

（2）同时<font style="color:rgb(243, 50, 50);">CPU在对图形渲染这块的处理也是常常会出现性能瓶颈问题</font>的。在渲染这块中，**<font style="color:rgb(243, 50, 50);">draw call调用</font>**、**<font style="color:rgb(243, 50, 50);">Batches批次</font>**、**<font style="color:rgb(243, 50, 50);">UI调用</font>**、**<font style="color:rgb(243, 50, 50);">物理组件</font>**的处理以及**<font style="color:rgb(243, 50, 50);">GC调用</font>**都是比较影响CPU性能的，所以这四块的内容优化会直接影响到CPU的性能。

（3）所以这里也主要针对这四块进行说明。



2.Draw call:<font style="color:rgb(243, 50, 50);">Draw call是CPU对底层图形接口的调用，是CPU提交数据 、指令、状态等内容给GPU的时候调用的，但由于GPU的计算速度往往比CPU调用draw call的快，如果CPU出现负载，那么会造成卡顿掉帧。</font>

<font style="color:rgb(243, 50, 50);">（1）优化的做法就是对同类资源进行合批渲染，静态资源看看能否进行合批，从而较少draw call次数。一般建议的draw call次数控制在100以内</font>。

（2）Draw call的数据也可以在unity的性能分析器里面查看，程序一般会在游戏中指令打印出来的，也可以通过指令查看。

![](https://cdn.nlark.com/yuque/0/2024/png/43256946/1713151572211-9a87ae89-2897-4b2b-8e22-f5169a042d17.png)



3.Batches批次合批：<font style="color:rgb(243, 50, 50);">合批有静态合批与动态合批，合批的目的是减少draw call的调用，从而降低CPU的性能压力</font>。

（1）静态合批是手动设置的：

1.<font style="color:rgb(243, 50, 50);">通过设置游戏中需要合批的模型资源，然后在游戏导出时，在Player setting里面设置static batching，这样设置后导出时unity就好帮我们合批了，不过这样会增大包体大小，但是会运行快一些</font>；

2.<font style="color:rgb(243, 50, 50);">在unity里面直接勾选static属性，这样设置时，物体是在加载过程中才进行合批，这样包体会更小，但是运行会慢一些，内存也会相应增大</font>。

（2）动态合批是unity引擎自动帮我们合批的，我们可以不用理会。不过动态合批有许多的限制：

+ <font style="color:rgb(243, 50, 50);">动态合批处理的物体顶点数量不超过900个，包括shader里的顶点设置</font>
+ <font style="color:rgb(243, 50, 50);">如果GameObjects在Transform上包含镜像，则不会对其进行动态合批处理</font>
+ <font style="color:rgb(243, 50, 50);">使用不同的Material实例会导致GameObjects不能一起批处理，即使它们基本相同</font>
+ <font style="color:rgb(243, 50, 50);">带有光照贴图的GameObjects有额外的渲染器参数：保存光照贴图的索引和偏移/缩放。一般来说，动态光照贴图的GameObjects应指向完全相同的光照贴图位置才能被动态合批处理</font>
+ <font style="color:rgb(243, 50, 50);"></font>

4.静态合批有渲染上的优点，但是也有缺点：合批后，在运行过程中会增加内存的消耗，所以对于<font style="color:rgb(243, 50, 50);">CPU与内存间</font>的优化需要衡量两者间的短板所在，择优而选，而不能一昧的追求极端，反而会影响到了其他方面的性能。



5.UI调用：会<font style="color:rgb(243, 50, 50);">增加CPU的负担的，不合理的UI布局和调用会导致CPU过渡绘制和调用，增加CPU性能压力</font>。

一般的优化策略：

+ <font style="color:rgb(0, 0, 0);">同一个UI界面的图片尽量合到一张图集里面去，减少draw call</font>
+ <font style="color:rgb(0, 0, 0);">通用的图片放到一张共享图集里面去</font>
+ <font style="color:rgb(0, 0, 0);">不同格式的图片放到不同的图集</font>
+ <font style="color:rgb(0, 0, 0);">减少图片的尺寸</font>
+ <font style="color:rgb(0, 0, 0);">合理使用UI层级，在一个UI工程里面，尽量不要使用复杂的UI结构</font>
+ <font style="color:rgb(0, 0, 0);">动态UI与静态UI进行分离，减少不必要的绘制</font>
+ <font style="color:rgb(0, 0, 0);">透明UI要慎用，可能会增加重绘</font>



6.物理组件：物理组件的大量使用，也会造成CPU的计算压力，对物理组件的优化策略有：

+ <font style="color:rgb(243, 50, 50);">尽量不使用网格碰撞器</font>
+ <font style="color:rgb(243, 50, 50);">选择使用合适的Fixed Timestep</font>



7.GC调用：<font style="color:#DF2A3F;">GC是用来优化内存的，但是频繁的调用也会增加CPU的处理逻辑开销，因此对于CPU的优化，减少GC调用出发也是一个操作</font>

GC触发的条件：

+ <font style="color:rgb(243, 50, 50);">堆内存不足，自动触发GC调用</font>
+ <font style="color:rgb(243, 50, 50);">程序手动调用GC</font>

问题一般会出现在程序手动频繁调用GC，同时也是因为一些<font style="color:rgb(243, 50, 50);">编程规范</font>引发了垃圾数据，系统堆内存过低而触发了GC。



## 五、影响GPU性能的因素
对GPU性能影响：主要体现在<font style="color:#DF2A3F;">渲染方面</font>的压力，导致的结果就是<font style="color:#DF2A3F;">游戏掉帧、耗电量过高、发热</font>等表现。

（1）GPU的功能就是计算，影响GPU计算效率的无非就是两大方面：

1.面数过多，像素计算复杂

2.GPU显存带宽

（2）主要优化策略：

+ <font style="color:rgb(243, 50, 50);">减少顶点数量</font>
+ <font style="color:rgb(243, 50, 50);">纹理图片尺寸不易过大</font>
+ <font style="color:rgb(243, 50, 50);">使用LOD技术</font>
+ <font style="color:rgb(243, 50, 50);">使用遮挡剔除</font>
+ <font style="color:rgb(243, 50, 50);">使用合图图集</font>
+ <font style="color:rgb(243, 50, 50);">大场景使用烘焙光影替代BPR光影</font>
+ <font style="color:rgb(243, 50, 50);">移动端类游戏，使用mobile版的shader</font>
+ <font style="color:rgb(243, 50, 50);">UI元素不使用mipmap设置（合理使用mipmap）</font>



## 六、客户端性能工具介绍与环境搭建
1.Unity Profiler

Unity自带的性能测试工具

总结：一般情况下只需要用Unity Profiler就能测试到游戏内各项内存使用情况，前提是对Profiler各项数据所表达的含义了然于心，尽量做到使用真机调试结合Profiler，了解到游戏运行的真实内存占用数据

AB包卸载驻留对比测试：[https://snh48group.yuque.com/rtukm5/project_doc/awgczgw7irypndmw?singleDoc#](https://snh48group.yuque.com/rtukm5/project_doc/awgczgw7irypndmw?singleDoc#) 



2.UWA

（1）UWA介绍：[https://www.uwa4d.com/](https://www.uwa4d.com/)

（2）UWA SDK接入：[https://snh48group.yuque.com/rtukm5/project_doc/ck49hrzuur36541k?singleDoc#](https://snh48group.yuque.com/rtukm5/project_doc/ck49hrzuur36541k?singleDoc#)

（3）UWA 性能测试报告：[https://snh48group.yuque.com/rtukm5/project_doc/rqbyf4pzs44951qi?singleDoc#](https://snh48group.yuque.com/rtukm5/project_doc/rqbyf4pzs44951qi?singleDoc#) 



3.Perfdog

腾讯旗下的perfdog可以用于检测客户端帧率、CPU甚至GPU等数据情况，关于perfdog的使用请参考官网说明：<u><font style="color:rgb(0, 0, 255);">https://perfdog.qq.com/</font></u>

这里可以讲一下关于perfdog的用例设计，我给出几点总结：

+ <font style="color:rgb(0, 0, 0);">用例设计时，尽量保持单一变量，从而使得检测数据更具有说服力</font>
+ <font style="color:rgb(0, 0, 0);">测试过程，每个步骤尽量在ferfdog中的timeline（时间轴）上面的tag编写清除，便于对比与定位问题</font>
+ <font style="color:rgb(0, 0, 0);">收集录制的文件命名尽量用下划线拼接，便于阅读，如:小米6x_主线</font>

<font style="color:rgb(0, 0, 0);"></font>

4.renderdoc的使用

<font style="color:rgb(243, 50, 50);">Renderdoc这个工具可以抓帧定位资源渲染加载过程的问题，同时也可以找出被抓取的界面的的资源名字与大小，用于定位一些资源、渲染速度、加载过程的性能问题</font>

<font style="color:rgb(243, 50, 50);"></font>

## 七、客户端性能测试点
客户端性能的测试点，不同项目功能不一样，不过可以抛砖引玉的给出一些思路，如下图所示给出一些常规的测试过程的几种情况。当然，具体的用例设计还是要在围绕下面的几种情况的同时，针对具体的功能进行细化。

![](https://cdn.nlark.com/yuque/0/2024/png/43256946/1713160875168-9b0ff46e-1df8-47fe-8875-97ea219fac0b.png)



